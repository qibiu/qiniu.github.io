<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[æƒ³ä¹°ä¸œè¥¿]]></title>
    <url>%2F2020%2F04%2F20%2F%E6%83%B3%E4%B9%B0%E4%B8%9C%E8%A5%BF%2F</url>
    <content type="text"><![CDATA[æ‰‹è¡¨è¿˜æ˜¯mbpå‘¢ã€‚ è¿‡å‡ å¤©æŠ¢åŠ¨æ£®é™å®šç‰ˆã€‚ å†è¿‡æ®µæ—¶é—´å°±æ˜¯å…­å››äº†ã€‚ åŽ»å¹´è¿˜å‘äº†åšï¼Œä»Šå¹´ä¹Ÿå‘ä¸ªã€‚]]></content>
  </entry>
  <entry>
    <title><![CDATA[å¥½æƒ³æ—©ç‚¹ç§»æ°‘]]></title>
    <url>%2F2020%2F04%2F20%2F%E5%A5%BD%E6%83%B3%E6%97%A9%E7%82%B9%E7%A7%BB%E6%B0%91%2F</url>
    <content type="text"><![CDATA[è¿™ç²ªå‘ä¸€å¤©éƒ½å‘†ä¸ä¸‹åŽ»äº†ï¼Œè¶Šæ¥è¶Šé«˜åŽ‹ï¼Œè¶Šæ¥è¶Šç–¯ç‹‚ã€‚çœŸçš„è¦åŠªåŠ›äº†ï¼Œæœ€è¿‘éƒ½å¼€å§‹æ”¶æŠ¤ç…§äº†ï¼Œå“ªå¤©å­¦æœé²œé—­å…³é”å›½ï¼Œå°±è·‘ä¸æŽ‰äº†ã€‚]]></content>
      <tags>
        <tag>ç§»æ°‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020å¹´-ç¬¬17å‘¨å‘¨è®¡åˆ’]]></title>
    <url>%2F2020%2F04%2F20%2F2020%E5%B9%B4-%E7%AC%AC17%E5%91%A8%E5%91%A8%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[æœ€è¿‘è‡ªå·±çš„èŠ‚å¥ä¸å¯¹ï¼Œç”±äºŽå·¥ä½œè°ƒåŠ¨å’Œå·¥ä½œå†…å®¹çš„å˜æ›´å·²ç»å¥½ä¹…æ²¡åˆ·é¢˜äº†ã€‚ç´§è¿«çš„æ—¶é—´è®©æˆ‘æ„è¯†åˆ°ä¸èƒ½å†è¿™æ ·ä¸‹åŽ»äº†ã€‚5å¹´çš„è®¡åˆ’å±žå®žå¤ªå¤§ï¼Œä»¥è‡³äºŽè®©æˆ‘æ¯æ¬¡æƒ³èµ·æ¥å°±å¤´ç–¼ï¼Œå¼€å§‹æ€€ç–‘è‡ªå·±èƒ½å¦åšåˆ°ã€‚ æ‰€ä»¥æˆ‘å†³å®šå°†è®¡åˆ’åˆ¶å®šå¾—æ›´å°æ›´ç»†è‡´ï¼Œä»¥å‘¨ä¸ºå•ä½ï¼Œæ¯å‘¨åˆ¶å®šä¸€æ¬¡ï¼Œä»Žè¿™å‘¨å¼€å§‹ï¼Œè¿™å‘¨æ˜¯ç¬¬17å‘¨ã€‚ TODO List: ä¸‹è½½Ankiï¼Œå¯¼å…¥å•è¯ã€‚(ä¸‹å¥½äº†ï¼Œå¯¼å…¥äº†7000ä¸ªå•è¯ï¼Œå«ç”šä¹ˆéº¦å…‹ç±³ä¼¦7000ï¼Œå¬èµ·æ¥åƒéº¦å“²ä¼¦åˆåƒå…‰è½®2000) Androidç‰ˆçš„ä¸è¦é’±ï¼ŒIOSè¦ US$24.99ï¼Œå®žåœ¨å¤ªè´µï¼Œä¸è¡Œå°±æŸå®å§ã€‚ï¼ˆæ·˜å®ä¹°çš„ç¾ŽåŒºkeyï¼‰ æœ¬å‘¨è®¡åˆ’ï¼š åˆ©ç”¨ä¸Šä¸‹ç­é€šå‹¤æ—¶é—´ç”¨AnkièƒŒå•è¯ï¼Œè¿™ä¸œè¥¿åº”è¯¥è¿˜æœ‰ç‚¹å­¦ä¹ æˆæœ¬ï¼Œéœ€è¦ç¢ç£¨ä¸‹ã€‚ï¼ˆåšåˆ°äº†ï¼‰ å‘¨äºŒæ‰“å¡ï¼ˆä»Šå¤©å¤§æ¦‚èƒŒäº†130ä¸ªï¼Œæ˜Žå¤©è°ƒæ•´åˆ°200ï¼‰ åˆ°å®¶ä¹‹åŽåˆ·é¢˜ã€‚ï¼ˆçœ‹ä»Šå¤©èƒ½ä¸èƒ½åšåˆ°ï¼‰ å‘¨äºŒï¼ˆæžœç„¶ä»Šå¤©æ²¡æœ‰åˆ·é¢˜ï¼Œå›žæ¥å°±å •è½äº†ï¼Œè¿˜å¥½å•è¯æ˜¯èƒŒäº†ï¼Œäº‰å–æ˜Žå¤©æ­¥å…¥æ­£è½¨ï¼‰ å‘¨æœ«çœ‹ä¹¦ï¼Œä¹°çš„é›…æ€ä¹¦çŽ°åœ¨ðŸ“¦è¿˜æ²¡å¼€å°å‘¢ã€‚ æœ¬å‘¨éšè®°ï¼š ä¸¢ä½ é›·å§†ï¼ŒçœŸçš„æ„Ÿè§‰è®°å¿†åŠ›ä¸‹é™äº†ã€‚æ—©ä¸Šä¸€ä¸ªanalogous(ç±»ä¼¼çš„)ï¼Œè¿˜æœ‰ä¸ªcollision(ç¢°æ’ž)èƒŒäº†ä¸ƒå…«éã€‚çœŸçš„è¦åŠªåŠ›äº†ï¼Œå†æ‹–å‡ å¹´ï¼Œè®°å¿†åŠ›ç²¾åŠ›ä¸‹é™æ›´ä¸¥é‡ï¼Œé‚£å°±åªèƒ½åœ¨è¿™é‡Œç­‰æ­»äº†ã€‚ ä»Šå¤©å¤§æ¦‚èƒŒäº†20ä¸ªæ–°è¯ï¼Œæ„Ÿè§‰æ»¡äº†ç‚¹ã€‚èƒŒå•è¯è¿™ç§äº‹å°±åº”è¯¥ä¸€æ¬¡æ€§èƒŒå¾ˆå¤šï¼Œç„¶åŽå¤ä¹ ã€‚æ¯”å¦‚åŒæ ·100ä¸ªå•è¯ï¼Œä¸€å¤©èƒŒ100ä¸ªç„¶åŽä¸æ–­å¤ä¹ ï¼Œæ•ˆæžœåº”è¯¥å¥½è¿‡æ¯å¤©èƒŒ10ä¸ªè¿™ç§ã€‚]]></content>
      <tags>
        <tag>å‘¨è®¡åˆ’</tag>
        <tag>è®¡åˆ’</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä»Šå¤©å¦ˆå¦ˆè¿˜è°ˆèµ·äº†ä½ ]]></title>
    <url>%2F2020%2F04%2F15%2F%E4%BB%8A%E5%A4%A9%E5%A6%88%E5%A6%88%E8%BF%98%E8%B0%88%E8%B5%B7%E4%BA%86%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[é—®æˆ‘ä¹‹å‰çš„å¥³å­©ï¼ˆæŒ‡ä½ ï¼‰æ€Žä¹ˆäº†ã€‚ï¼ˆå› ä¸ºä¹‹å‰ç”Ÿæ—¥é€æˆ‘æ‰‹é“¾ï¼Œæˆ‘è·Ÿå¦ˆå¦ˆè¯´è¿‡ä½ ï¼Œæ‰€ä»¥å¥¹çŸ¥é“ã€‚ï¼‰ å”‰ï¼Œæœ¬æ¥æŒºå¥½çš„ã€‚è¿˜æƒ³ç€ç­‰è€å¦ˆç”Ÿæ—¥ï¼Œæˆ‘ä¹°ä¸ªç¤¼ç‰©ç»™å¥¹ï¼Œå°±è¯´æ˜¯æˆ‘ä»¬ä¸€èµ·é€çš„å¤šå¥½ï¼Œåˆ·åˆ·å¥½æ„Ÿåº¦ã€‚ å¥ˆä½•å‘€å¥ˆä½•ã€‚ ä¸€æœˆä»½å“„ä½ åˆ°å››æœˆä»½ï¼Œè¿˜è¦æ€Žä¹ˆæ ·ï¼Œæ›´ä½•å†µæˆ‘åˆæ²¡åšé”™ä»€ä¹ˆï¼Œæˆ‘åŠˆè…¿äº†å—ï¼Œè¿˜æ˜¯å‡ºè½¨äº†ï¼Ÿ ä½ ç”Ÿæ°”å› ä¸ºæˆ‘è¯´éš¾å¬çš„è¯ï¼Œæˆ‘ä¸ºä»€ä¹ˆè¯´éš¾å¬çš„è¯ï¼Ÿå› ä¸ºä½ åˆæ˜¯æ‹‰é»‘æˆ‘åˆæ˜¯éª‚æˆ‘ï¼Œè€ç€æ€§å­å“„äº†ä½ å¥½ä¹…éƒ½æ²¡ååº”ã€‚ä½ åˆä¸ºä»€ä¹ˆéª‚æˆ‘å‘¢ï¼Ÿå¤§æ¦‚æ˜¯å› ä¸ºæˆ‘ä¸€ä¸ªæœˆæ²¡ç†ä½ ã€‚è€Œæˆ‘åˆä¸ºä»€ä¹ˆä¸€ä¸ªæœˆæ²¡ç†ä½ å‘¢ï¼Ÿå› ä¸ºä½ é‚£å¥â€œæˆ‘ä»¬æ˜¯æ™®é€šåŒå­¦å…³ç³»â€ã€‚è‡³äºŽä½ é‚£æ¡æœ‹å‹åœˆå°±ä¸è¯´äº†ã€‚ æŠ±æ­‰ï¼Œæˆ‘è·Ÿæ™®é€šåŒå­¦è¿˜çœŸä¸è®²è¯ï¼Œåˆ«è¯´ä¸€ä¸ªæœˆäº†ï¼Œä¸€å¹´åˆ°å¤´éƒ½ä¸ä¼šè®²ä¸€å¥è¯ã€‚]]></content>
      <tags>
        <tag>ç”Ÿæ´»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-156 Binary Tree Upside Down]]></title>
    <url>%2F2020%2F04%2F13%2FLeetCode-156%2F</url>
    <content type="text"><![CDATA[é‡åˆ°çš„ç¬¬ä¸€ä¸ªä¸Šé”çš„é¢˜ï¼Œä»€ä¹ˆä¿¡æ¯éƒ½æ²¡æœ‰ã€‚ æœ‰ç‚¹åƒç¥žå¥‡å®è´é‡Œé¢çš„â€œçŒœçŒœæˆ‘æ˜¯è°â€çŽ¯èŠ‚ã€‚]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-145 Binary Tree Postorder Traversal]]></title>
    <url>%2F2020%2F04%2F13%2FLeetCode-145%2F</url>
    <content type="text"><![CDATA[Level: Hard Given a binary tree, return the postorder traversal of its nodesâ€™ values. Example: 12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [3,2,1] Follow up: Recursive solution is trivial, could you do it iteratively? æ€è·¯: åŽåºéåŽ†éš¾åº¦å±…ç„¶æ˜¯Hardï¼Œå¯èƒ½æŒ‡çš„æ˜¯é¢˜ç›®çš„é¢å¤–è¦æ±‚ä½¿ç”¨è¿­ä»£å®žçŽ°å§ã€‚ä½¿ç”¨è¿­ä»£ç¡®å®žå¾ˆç®€å•ï¼Œå…ˆå†™ä¸ªè¯•è¯•ã€‚ ä»£ç : 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); helper(root, result); return result; &#125; public void helper(TreeNode root, List&lt;Integer&gt; result)&#123; if (root == null)&#123; return; &#125; helper(root.left, result); helper(root.right, result); result.add(root.val); return; &#125;&#125; ç”¨é€’å½’å†™ç¡®å®žå¾ˆç®€å•ï¼Œä¸­é—´ç²—å¿ƒï¼Œpublic void helper(TreeNode root, List&lt;Integer&gt; result)å†™æŽ‰äº†List&lt;Integer&gt;ç›´æŽ¥å†™äº†resultï¼Œå…¶ä»–éƒ½ðŸ†—ã€‚ æˆ‘æ³¨æ„åˆ°è¿™ä¸¤é¢˜å†…å­˜ä½¿ç”¨ï¼ŒåŸºæœ¬éƒ½åªè¶…è¿‡äº†5%çš„äººï¼Œè¯´æ˜Žè¿­ä»£çš„æ–¹æ³•æ›´çœå†…å­˜å‘€ï¼ŒæŠ½ç©ºå¾—å­¦ä¸‹ä¸‰ç§éåŽ†è¿­ä»£çš„å†™æ³•ã€‚è®°å¾—ä¹‹å‰å“ªä¸€é¢˜ç”¨åˆ°è¿‡ï¼Œä¸è¿‡åªå†™è¿‡ä¸€æ¬¡ï¼Œå°è±¡ä¸æ·±åˆ»ã€‚ è¿­ä»£ç‰ˆå¾…ç»­ å¤ä¹ : Time Submitted Status Runtime Memory Language 9 minutes ago Accepted 0 ms 38.3 MB java Last update time: 2020å¹´4æœˆ13æ—¥ 10ç‚¹47åˆ†]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-144 Binary Tree Preorder Traversal]]></title>
    <url>%2F2020%2F04%2F13%2FLeetCode-144%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree, return the preorder traversal of its nodesâ€™ values. Example: 12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [1,2,3] Follow up: Recursive solution is trivial, could you do it iteratively? æ€è·¯: å“¦åš¯~ç®€å•çš„å…ˆåºéåŽ†ï¼Œçº¯æ‰‹æ•²ä¸€æ¬¡è¿‡ã€‚ ä»£ç : 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if (root == null)&#123; return result; &#125; helper(root, result); return result; &#125; public void helper(TreeNode root, List&lt;Integer&gt; result)&#123; if (root != null)&#123; result.add(root.val); &#125; if (root.left != null)&#123; helper(root.left, result); &#125; if (root.right != null)&#123; helper(root.right, result); &#125; return; &#125;&#125; å…¶å®žä»£ç å¯ä»¥ç²¾ç®€ä¸€ä¸‹ï¼Œä¸Šé¢æ˜¯ç¬¬ä¸€æ¬¡çš„ç‰ˆæœ¬ï¼Œä¸‹é¢æ˜¯ç¬¬äºŒæ¬¡çš„ç‰ˆæœ¬ï¼Œæ”¹åŠ¨ä¸å¤§ï¼Œå°±æ˜¯è¡Œæ•°å˜å°‘äº†ã€‚ 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); helper(root, result); return result; &#125; public void helper(TreeNode root, List&lt;Integer&gt; result)&#123; if (root == null)&#123; return; &#125; result.add(root.val); helper(root.left, result); helper(root.right, result); return; &#125;&#125; å¤ä¹ : Time Submitted Status Runtime Memory Language 7 minutes ago Accepted 0 ms 37.5 MB java 11 minutes ago Accepted 0 ms 37.7 MB java Last update time : 2020å¹´4æœˆ13æ—¥ 10ç‚¹30åˆ†]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é…’æŠ¢åˆ°äº†ï¼Œäººæ²¡äº†]]></title>
    <url>%2F2020%2F04%2F12%2F%E9%85%92%E6%8A%A2%E5%88%B0%E4%BA%86%EF%BC%8C%E4%BA%BA%E6%B2%A1%E4%BA%86%2F</url>
    <content type="text"><![CDATA[ä½ ç”Ÿæ°”ï¼Œæˆ‘è¿˜æœ‰æ°”å‘¢ã€‚]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-129 Sum Root to Leaf Numbers]]></title>
    <url>%2F2020%2F04%2F12%2FLeetCode-129%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Example: 123456789Input: [1,2,3] 1 / \ 2 3Output: 25Explanation:The root-to-leaf path 1-&gt;2 represents the number 12.The root-to-leaf path 1-&gt;3 represents the number 13.Therefore, sum = 12 + 13 = 25. Example 2: 123456789101112Input: [4,9,0,5,1] 4 / \ 9 0 / \5 1Output: 1026Explanation:The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.The root-to-leaf path 4-&gt;0 represents the number 40.Therefore, sum = 495 + 491 + 40 = 1026. æ€è·¯: â€‹ æˆ‘çš„æƒ³æ³•æ˜¯åˆ©ç”¨å…ˆåºéåŽ†ï¼Œå…ˆåŽèŽ·å–åˆ°æ ¹å’Œå­èŠ‚ç‚¹çš„å€¼ã€‚å†ç”¨StringBuilderçš„append()æ–¹æ³•ï¼Œæ‹¼å‡ºä¸€ä¸ªStringç±»åž‹çš„æ•°ï¼Œå†addè¿›ä¸€ä¸ªList&lt;String&gt;ã€‚æœ€åŽéåŽ†Listï¼ŒåŒæ—¶æŠŠStringè½¬æˆintç›¸åŠ è¿”å›žã€‚æœ€åŽç‚¹å‡»Run CodeæˆåŠŸäº†ï¼Œæ¿€åŠ¨ï¼ŒæŽ¥ç€ç‚¹å‡»SubmitæŠ¥é”™äº†ï¼Œä¸€ç‚¹ä¹Ÿä¸åƒæƒŠå‘¢ã€‚ é”™è¯¯ç­”æ¡ˆ: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int sumNumbers(TreeNode root) &#123; List&lt;String&gt; sl = new ArrayList&lt;String&gt;(); if(root == null)&#123; return 0; &#125; int result = 0; helper(root.left, root.right, sl, root.val); for (int i = 0; i &lt; sl.size(); i++)&#123; int temp = Integer.parseInt(sl.get(i)); result += temp; &#125; return result; &#125; public int helper(TreeNode left, TreeNode right, List&lt;String&gt; sl, int rootVal)&#123; if (left != null)&#123; StringBuilder sb = new StringBuilder(); sb.append(rootVal); sb.append(left.val); sl.add(sb.toString()); &#125; if (right != null)&#123; StringBuilder sb = new StringBuilder(); sb.append(rootVal); sb.append(right.val); sl.add(sb.toString()); &#125; // sl.add(sb.toString()); if (left.left != null &amp;&amp; right.right != null)&#123; return helper(left.left, right.right, sl, rootVal); &#125; return 0; &#125;&#125; æ­£ç¡®ä»£ç : 123456789public int sumNumbers(TreeNode root) &#123; return sum(root, 0);&#125;public int sum(TreeNode n, int s)&#123; if (n == null) return 0; if (n.right == null &amp;&amp; n.left == null) return s*10 + n.val; return sum(n.left, s*10 + n.val) + sum(n.right, s*10 + n.val);&#125; æžœç„¶ç®—æ³•çš„æ­£ç¡®ç­”æ¡ˆä¸€èˆ¬éƒ½ä¸ä¼šå¤ªé•¿ï¼ŒHardéš¾åº¦å¦è¯´ï¼Œä¹‹å‰ç¢°åˆ°çš„Morris Traversalå°±æŒºé•¿çš„ã€‚ è¯´å®žè¯ä¸å¤ªä¼šä¸ªåç™¾ä½æ•°çš„è½¬æ¢ï¼Œæ‰€ä»¥ç¬¬ä¸€æƒ³æ³•æ˜¯å…ˆæ‹¼æˆStringå†è½¬intï¼Œè™½ç„¶æ˜ŽçŸ¥è¿™æ ·æ•ˆçŽ‡ä¸é«˜ï¼Œè¿˜æœ‰å¯èƒ½æŠ¥è½¬æ¢å¼‚å¸¸ã€‚ ä»Šå¤©å…ˆåˆ°è¿™å§ã€‚ å¤ä¹ : ç•™ä¸ªå‘ Time Submitted Status Runtime Memory Language 14 minutes ago Wrong Answer N/A N/A java 14 minutes ago Wrong Answer N/A N/A java]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-99 Recover Binary Search Tree]]></title>
    <url>%2F2020%2F04%2F12%2FLeetCode-99%2F</url>
    <content type="text"><![CDATA[Level: Hard Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: 123456789101112131415Input: [1,3,null,null,2] 1 / 3 \ 2Output: [3,1,null,null,2] 3 / 1 \ 2 Example 2: 123456789101112131415Input: [3,1,4,null,null,2] 3 / \1 4 / 2Output: [2,1,4,null,null,3] 2 / \1 4 / 3 Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? åŽŸæ¥è¿™ä¸ªæ‰æ˜¯æˆ‘é‡åˆ°çš„ç¬¬ä¸€ä¸ªéš¾åº¦ä¸ºHardçš„é¢˜ ä¸­åºéåŽ†ä¸ç¬¦åˆé¢˜ç›®å¸¸æ•°ç©ºé—´çš„è¦æ±‚ï¼Œç„¶åŽå°±æœ‰äº†èŽ«é‡Œæ–¯éåŽ† Morris Traversal 12345678910111213141516171819202122232425262728293031323334353637383940414243public void recoverTree(TreeNode root) &#123; TreeNode pre = null; TreeNode first = null, second = null; // Morris Traversal TreeNode temp = null; while(root!=null)&#123; if(root.left!=null)&#123; // connect threading for root temp = root.left; while(temp.right!=null &amp;&amp; temp.right != root) temp = temp.right; // the threading already exists if(temp.right!=null)&#123; if(pre!=null &amp;&amp; pre.val &gt; root.val)&#123; if(first==null)&#123;first = pre;second = root;&#125; else&#123;second = root;&#125; &#125; pre = root; temp.right = null; root = root.right; &#125;else&#123; // construct the threading temp.right = root; root = root.left; &#125; &#125;else&#123; if(pre!=null &amp;&amp; pre.val &gt; root.val)&#123; if(first==null)&#123;first = pre;second = root;&#125; else&#123;second = root;&#125; &#125; pre = root; root = root.right; &#125; &#125; // swap two node values; if(first!= null &amp;&amp; second != null)&#123; int t = first.val; first.val = second.val; second.val = t; &#125; &#125;//https://leetcode.com/problems/recover-binary-search-tree/discuss/32559/Detail-Explain-about-How-Morris-Traversal-Finds-two-Incorrect-Pointer çœ‹ä¸æ‡‚ï¼Œä»Šå¤©è¿˜ä¸€é¢˜éƒ½æ²¡æœ‰åšã€‚]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-98 Validate Binary Search Tree]]></title>
    <url>%2F2020%2F04%2F12%2FLeetCode-98%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the nodeâ€™s key. The right subtree of a node contains only nodes with keys greater than the nodeâ€™s key. Both the left and right subtrees must also be binary search trees. Example 1: 123456 2 / \ 1 3Input: [2,1,3]Output: true Example 2: 123456789 5 / \ 1 4 / \ 3 6Input: [5,1,4,null,null,3,6]Output: falseExplanation: The root node&apos;s value is 5 but its right child&apos;s value is 4. æ–¹æ³•ä¸€: 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isValidBST(TreeNode root) &#123; if (root == null) return true; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode pre = null; while (root != null || !stack.isEmpty()) &#123; // while (root != null) &#123; stack.push(root); root = root.left; &#125; root = stack.pop(); if(pre != null &amp;&amp; root.val &lt;= pre.val) return false; pre = root; root = root.right; &#125; return true; &#125;&#125; æ–¹æ³•äºŒï¼š 1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isValidBST(TreeNode root) &#123; return helper(root,Integer.MIN_VALUE,Integer.MAX_VALUE); &#125; public boolean helper(TreeNode root,Integer min, Integer max)&#123; if (root == null)&#123; return true; &#125; if (root.val &gt;= max || root.val &lt;= min) return false; return helper(root.left, min, root.val)&amp;&amp;helper(root.right,root.val,max); &#125; &#125; Test case: [2147483647]ä¼šæŠ¥é”™ï¼Œæ­£å¥½æ˜¯ Integer.MAX_VALUEçš„ä¸´ç•Œå€¼ã€‚ æ–¹æ³•äºŒæ”¹(è‡ªå·±): 1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isValidBST(TreeNode root) &#123; return helper(root,Long.MIN_VALUE,Long.MAX_VALUE); &#125; public boolean helper(TreeNode root,Long min, Long max)&#123; if (root == null)&#123; return true; &#125; if (root.val &gt;= max || root.val &lt;= min) return false; return helper(root.left, Long.valueOf(min), Long.valueOf(root.val)) &amp;&amp; helper(root.right,Long.valueOf(root.val),Long.valueOf(max)); &#125; &#125; æƒ³æ³•ä¹Ÿå¾ˆç®€å•ï¼ŒæŠŠIntegeræ¢æˆLongï¼Œè¿™æ ·é‡åˆ°è¿™ä¸ªtest caseå°±ä¸ä¼šæŠ¥é”™äº†ã€‚ æ–¹æ³•äºŒæ”¹(è¯„è®ºåŒº): 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isValidBST(TreeNode root) &#123; return helper(root, null, null); &#125; boolean helper(TreeNode root, Integer min, Integer max) &#123; if (root == null) return true; if ((min != null &amp;&amp; root.val &lt;= min) || (max != null &amp;&amp; root.val &gt;= max)) return false; return helper(root.left, min, root.val) &amp;&amp; helper(root.right, root.val, max); &#125;&#125;// é“¾æŽ¥ï¼šhttps://leetcode.com/problems/validate-binary-search-tree/discuss/32138/Another-passed-Java-solution è¿™ç§æ›´ä¼˜é›…ï¼Œç”¨æˆ‘é‚£ç§æ–¹æ³•ï¼Œtest caseæ¢ä¸ªLongçš„ä¸´ç•Œå€¼ï¼Œä¼°è®¡åˆä¼šæŠ¥é”™äº†ã€‚åªæ˜¯ç®—æš‚æ—¶è§£å†³äº†é—®é¢˜ï¼Œå¹¶æ²¡æœ‰å®Œå…¨è§£å†³é—®é¢˜ã€‚ å¤ä¹ è®°å½•: Time Submitted Status Runtime Memory Language 9 minutes ago Accepted 0 ms 39.3 MB java 13 minutes ago Accepted 0 ms 39.1 MB java 21 minutes ago Wrong Answer N/A N/A java 9 days ago Accepted 1 ms 39.5 MB java Last Update Time : 2020å¹´4æœˆ10æ—¥ 10ç‚¹52åˆ†]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-96 Unique Binary Search Trees]]></title>
    <url>%2F2020%2F04%2F12%2FLeetCode-96%2F</url>
    <content type="text"><![CDATA[Level: Medium Given n, how many structurally unique BSTâ€™s (binary search trees) that store values 1 â€¦ n? Example: 12345678910Input: 3Output: 5Explanation:Given n = 3, there are a total of 5 unique BST&apos;s: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 æš‚ç©º]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-95 Unique Binary Search Trees II]]></title>
    <url>%2F2020%2F04%2F12%2FLeetCode-95%2F</url>
    <content type="text"><![CDATA[Level: Medium Given an integer n, generate all structurally unique BSTâ€™s (binary search trees) that store values 1 â€¦ n. Example: 1234567891011121314151617Input: 3Output:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]Explanation:The above output corresponds to the 5 unique BST&apos;s shown below: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 æš‚ç©º]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-94 Binary Tree Inorder Traversal]]></title>
    <url>%2F2020%2F04%2F12%2FLeetCode-94%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree, return the inorder traversal of its nodesâ€™ values. Example: 12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively? æ€è·¯: â€‹ ä¸€ä¸ªç®€å•çš„ä¸­åºéåŽ† ä»£ç : 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if (root == null)&#123; return result; &#125; helper(root, result); return result; &#125; public List&lt;Integer&gt; helper(TreeNode root, List&lt;Integer&gt; result)&#123; if (root.left != null)&#123; helper(root.left, result); &#125; result.add(root.val); if (root.right != null)&#123; helper(root.right, result); &#125; return result; &#125;&#125; å¤ä¹ (æäº¤è®°å½•): Time Submitted Status Runtime Memory Language 7 minutes ago Accepted 0 ms 37.8 MB java 7 days ago Accepted 0 ms 37.3 MB java 9 days ago Accepted 0 ms 37.8 MB java Last update time : 2020å¹´4æœˆ9æ—¥ 17ç‚¹24åˆ†]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-124 Binary Tree Maximum Path Sum]]></title>
    <url>%2F2020%2F04%2F09%2FLeetCode-124%2F</url>
    <content type="text"><![CDATA[Level: Hard Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1: 1234567Input: [1,2,3] 1 / \ 2 3Output: 6 Example 2: 123456789Input: [-10,9,20,null,null,15,7] -10 / \ 9 20 / \ 15 7Output: 42 é‡åˆ°çš„ç¬¬ä¸€ä¸ªéš¾åº¦ä¸ºHardçš„é¢˜ï¼Œè¿™ä¸ªå•è¯ç›´æŽ¥è®©æˆ‘æ”¾å¼ƒäº†æ€è€ƒï¼Œç›´å¥”è¯„è®ºåŒºã€‚ çœŸæ˜¯ä»–å¦ˆçš„ä¼˜é›…å‘€ 1234567891011121314151617181920212223public class Solution &#123; int max = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) &#123; helper(root); return max; &#125; // helper returns the max branch // plus current node's value int helper(TreeNode root) &#123; if (root == null) return 0; int left = Math.max(helper(root.left), 0); int right = Math.max(helper(root.right), 0); max = Math.max(max, root.val + left + right); return root.val + Math.max(left, right); &#125;&#125;// é“¾æŽ¥ï¼šhttps://leetcode.com/problems/binary-tree-maximum-path-sum/discuss/39875/Elegant-Java-solution è™½ç„¶è¿˜ä¸æ˜¯å¾ˆæ‡‚è¿™ä¸¤è¡Œ 123max = Math.max(max, root.val + left + right);return root.val + Math.max(left, right);]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-117 Populating Next Right Pointers in Each Node II]]></title>
    <url>%2F2020%2F04%2F09%2FLeetCode-117%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Follow up: You may only use constant extra space. Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem. Example 1: 123Input: root = [1,2,3,4,5,null,7]Output: [1,#,2,3,#,4,5,7,#]Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &apos;#&apos; signifying the end of each level. Constraints: The number of nodes in the given tree is less than 6000. -100 &lt;= node.val &lt;= 100 æ€è·¯: â€‹ ç”¨ä¸Šä¸€é¢˜çš„å±‚æ¬¡éåŽ†çš„è¯è²Œä¼¼ä¸éœ€è¦æ”¹ä»£ç ï¼Œè¯´å¹²å°±å¹²ï¼Œè¶ç€è®°å¿†è¿˜çƒ­ä¹Žç€ï¼ŒæŠŠ116çš„ä»£ç ç äº†ä¸€éï¼Œç”±äºŽæ‰‹æ‰“è¿˜æ˜¯å‡ºçŽ°äº†ä¸€äº›æ³¢æŠ˜ï¼Œ æ¯”å¦‚Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();å°‘æ‰“äº†å‰é¢çš„&lt;Node&gt;ï¼Œæ¯•ç«Ÿä¹‹å‰éƒ½æ˜¯ç”¨IDEAï¼Œæ•²åŽé¢çš„new LinkedList&lt;Node&gt;();ç”¨å¿«æ·é”®è‡ªåŠ¨ç”Ÿæˆå‰é¢ã€‚ å†å°±æ˜¯queue.size()å°‘äº†(),è¿˜æ˜¯åŒæ ·çš„ç†ç”±ï¼Œä¹‹å‰éƒ½æ˜¯è‡ªåŠ¨è¡¥å…¨çš„ä»£ç ã€‚ è¿˜æœ‰å°±æ˜¯Node node = queue.poll();å†™åœ¨äº†forå¾ªçŽ¯çš„å¤–é¢ã€‚ æœ€åŽå°±æ˜¯node.next = queue.peek();ä¸çŸ¥é“å·¦è¾¹åº”è¯¥å†™ä»€ä¹ˆã€‚ å¤§ä½“ä¸Šè¿˜æ˜¯OKçš„ï¼Œæ²¡æœ‰å‡ºçŽ°Runtime Exceptionï¼Œå‡ ä¸ªç¼–è¯‘å¼‚å¸¸ä¹Ÿéƒ½åŠæ—¶å‘çŽ°å¹¶è§£å†³äº†ï¼Œæ²¡æœ‰å‡ºçŽ°æ‰¾äº†å¾ˆä¹…æ²¡å‘çŽ°é”™å“ªçš„é—®é¢˜ã€‚ ä½†æ˜¯å±‚çº§éåŽ†çš„ç©ºé—´å¤æ‚åº¦ä¸ºï¼Œå¹¶ä¸ç¬¦åˆé¢˜ç›®çš„è¿›é˜¶è¦æ±‚ã€‚ å±‚çº§éåŽ†: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node next; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val, Node _left, Node _right, Node _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123; public Node connect(Node root) &#123; if (root == null)&#123; return null; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); queue.offer(root); while (queue.size() &gt; 0)&#123; int size = queue.size(); for (int i = 0; i &lt; size; i++)&#123; Node node = queue.poll(); if (i &lt; size -1)&#123; node.next = queue.peek(); &#125; if (node.left != null)&#123; queue.add(node.left); &#125; if (node.right != null)&#123; queue.add(node.right); &#125; &#125; &#125; return root; &#125;&#125; ç©ºé—´å¤æ‚åº¦ä¸ºçš„æ–¹æ³•è¿˜æ²¡ä»”ç»†çœ‹ï¼Œæ„Ÿè§‰æŒºå¤æ‚çš„ï¼Œä¹Ÿè´´ä¸€ä¸‹å§ã€‚ 1234567891011121314151617181920212223242526public class Solution &#123; public void connect(TreeLinkNode root) &#123; if (root == null) return; TreeLinkNode curP = root; TreeLinkNode nextDummyHead = new TreeLinkNode(0); TreeLinkNode p = nextDummyHead; while (curP != null) &#123; if (curP.left != null) &#123; p.next = curP.left; p = p.next; &#125; if (curP.right != null) &#123; p.next = curP.right; p = p.next; &#125; if (curP.next != null) &#123; curP = curP.next; &#125; else &#123; curP = nextDummyHead.next; nextDummyHead.next = null; p = nextDummyHead; &#125; &#125; &#125;&#125; é“¾æŽ¥ï¼šhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/discuss/37828/O(1)-space-O(n)-complexity-Iterative-Solution]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-116 Populating Next Right Pointers in Each Node]]></title>
    <url>%2F2020%2F04%2F09%2FLeetCode-116%2F</url>
    <content type="text"><![CDATA[Level: Medium You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Follow up: You may only use constant extra space. Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem. Example 1: 123Input: root = [1,2,3,4,5,6,7]Output: [1,#,2,3,#,4,5,6,7,#]Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &apos;#&apos; signifying the end of each level. Constraints: The number of nodes in the given tree is less than 4096. -1000 &lt;= node.val &lt;= 1000 ä¸ªäººæ€è·¯: â€‹ å±‚æ¬¡éåŽ† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node next; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val, Node _left, Node _right, Node _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123; public Node connect(Node root) &#123; if (root == null)&#123; return root; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); queue.offer(root); while(queue.size() &gt; 0 &amp;&amp; queue != null)&#123; int size = queue.size(); for(int i = 0; i &lt; size; i++)&#123; Node node = queue.poll(); if (i &lt; size - 1) &#123; node.next = queue.peek(); &#125; if (node.left != null)&#123; queue.offer(node.left); &#125; if (node.right != null)&#123; queue.offer(node.right); &#125; &#125; &#125; return root; &#125; &#125; æˆ‘çš„ç‰ˆæœ¬å°‘äº†å¦‚ä¸‹è¿™ä¸€æ®µï¼Œå¯¼è‡´æŠ¥é”™ã€‚ if (i &lt; size - 1) { node.next = queue.peek(); }è¿˜æœ‰ä¸€ç§æ›´ä¼˜é›…çš„æ–¹æ³•ï¼Œä¸è¿‡å•çœ‹ä»£ç ä¸å®¹æ˜“ç†è§£ 1234567891011121314151617public class Solution &#123; public void connect(TreeLinkNode root) &#123; TreeLinkNode level_start=root; while(level_start!=null)&#123; TreeLinkNode cur=level_start; while(cur!=null)&#123; if(cur.left!=null) cur.left.next=cur.right; if(cur.right!=null &amp;&amp; cur.next!=null) cur.right.next=cur.next.left; cur=cur.next; &#125; level_start=level_start.left; &#125; &#125;&#125;é“¾æŽ¥ï¼šhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/37461/Java-solution-with-O(1)-memory%2B-O(n)-time æ­é…å›¾è§£æ›´æ–¹ä¾¿ç†è§£ï¼Œä»¥ä¸‹èŠ‚é€‰è‡ªåŠ›æ‰£ä¸­å›½ é“¾æŽ¥ï¼šhttps://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/solution/tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-j-3/ æ–¹æ³•äºŒï¼šä½¿ç”¨å·²å»ºç«‹çš„ next æŒ‡é’ˆæ€è·¯ ä¸€æ£µæ ‘ä¸­ï¼Œå­˜åœ¨ä¸¤ç§ç±»åž‹çš„ next æŒ‡é’ˆã€‚ ç¬¬ä¸€ç§æƒ…å†µæ˜¯è¿žæŽ¥åŒä¸€ä¸ªçˆ¶èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹ã€‚å®ƒä»¬å¯ä»¥é€šè¿‡åŒä¸€ä¸ªèŠ‚ç‚¹ç›´æŽ¥è®¿é—®åˆ°ï¼Œå› æ­¤æ‰§è¡Œä¸‹é¢æ“ä½œå³å¯å®Œæˆè¿žæŽ¥ã€‚ 1node.left.next = node.right ç¬¬äºŒç§æƒ…å†µåœ¨ä¸åŒçˆ¶äº²çš„å­èŠ‚ç‚¹ä¹‹é—´å»ºç«‹è¿žæŽ¥ï¼Œè¿™ç§æƒ…å†µä¸èƒ½ç›´æŽ¥è¿žæŽ¥ã€‚ å¦‚æžœæ¯ä¸ªèŠ‚ç‚¹æœ‰æŒ‡å‘çˆ¶èŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œå¯ä»¥é€šè¿‡è¯¥æŒ‡é’ˆæ‰¾åˆ° `next` èŠ‚ç‚¹ã€‚å¦‚æžœä¸å­˜åœ¨è¯¥æŒ‡é’ˆï¼Œåˆ™æŒ‰ç…§ä¸‹é¢æ€è·¯å»ºç«‹è¿žæŽ¥ï¼š ç¬¬ N å±‚èŠ‚ç‚¹ä¹‹é—´å»ºç«‹ next æŒ‡é’ˆåŽï¼Œå†å»ºç«‹ç¬¬ N+1 å±‚èŠ‚ç‚¹çš„ next æŒ‡é’ˆã€‚å¯ä»¥é€šè¿‡ next æŒ‡é’ˆè®¿é—®åŒä¸€å±‚çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨ç¬¬ N å±‚çš„ next æŒ‡é’ˆï¼Œä¸ºç¬¬ N+1 å±‚èŠ‚ç‚¹å»ºç«‹ next æŒ‡é’ˆã€‚ ç®—æ³• ä»Žæ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œç”±äºŽç¬¬ 0 å±‚åªæœ‰è¿™ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ‰€ä»¥ä¸éœ€è¦è¿žæŽ¥ã€‚ç›´æŽ¥ä¸ºç¬¬ 1 å±‚èŠ‚ç‚¹å»ºç«‹ next æŒ‡é’ˆå³å¯ã€‚è¯¥ç®—æ³•ä¸­éœ€è¦æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼Œå½“æˆ‘ä»¬ä¸ºç¬¬ N å±‚èŠ‚ç‚¹å»ºç«‹ next æŒ‡é’ˆæ—¶ï¼Œå¤„äºŽç¬¬ N-1Nâˆ’1 å±‚ã€‚å½“ç¬¬ NN å±‚èŠ‚ç‚¹çš„ next æŒ‡é’ˆå…¨éƒ¨å»ºç«‹å®ŒæˆåŽï¼Œç§»è‡³ç¬¬ NN å±‚ï¼Œå»ºç«‹ç¬¬ N+1N+1 å±‚èŠ‚ç‚¹çš„ next æŒ‡é’ˆã€‚ éåŽ†æŸä¸€å±‚çš„èŠ‚ç‚¹æ—¶ï¼Œè¿™å±‚èŠ‚ç‚¹çš„ next æŒ‡é’ˆå·²ç»å»ºç«‹ã€‚å› æ­¤æˆ‘ä»¬åªéœ€è¦çŸ¥é“è¿™ä¸€å±‚çš„æœ€å·¦èŠ‚ç‚¹ï¼Œå°±å¯ä»¥æŒ‰ç…§é“¾è¡¨æ–¹å¼éåŽ†ï¼Œä¸éœ€è¦ä½¿ç”¨é˜Ÿåˆ—ã€‚ ä¸Šé¢æ€è·¯çš„ä¼ªä»£ç å¦‚ä¸‹ï¼š 123456789101112leftmost = rootwhile (leftmost.left != null)&#123; head = leftmost while (head.next != null) &#123; 1) Establish Connection 1 2) Establish Connection 2 using next pointers head = head.next &#125; leftmost = leftmost.left&#125; ä¸¤ç§ç±»åž‹çš„ next æŒ‡é’ˆï¼Œ ç¬¬ä¸€ç§æƒ…å†µä¸¤ä¸ªå­èŠ‚ç‚¹å±žäºŽåŒä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œå› æ­¤ç›´æŽ¥é€šè¿‡çˆ¶èŠ‚ç‚¹å»ºç«‹ä¸¤ä¸ªå­èŠ‚ç‚¹çš„ next æŒ‡é’ˆå³å¯ã€‚ 1node.left.next = node.right ç¬¬äºŒç§æƒ…å†µæ˜¯è¿žæŽ¥ä¸åŒçˆ¶èŠ‚ç‚¹ä¹‹é—´å­èŠ‚ç‚¹çš„æƒ…å†µã€‚æ›´å…·ä½“åœ°è¯´ï¼Œè¿žæŽ¥çš„æ˜¯ç¬¬ä¸€ä¸ªçˆ¶èŠ‚ç‚¹çš„å³å­©å­å’Œç¬¬äºŒçˆ¶èŠ‚ç‚¹çš„å·¦å­©å­ã€‚ç”±äºŽå·²ç»åœ¨çˆ¶èŠ‚ç‚¹è¿™ä¸€å±‚å»ºç«‹äº† next æŒ‡é’ˆï¼Œå› æ­¤å¯ä»¥ç›´æŽ¥é€šè¿‡ç¬¬ä¸€ä¸ªçˆ¶èŠ‚ç‚¹çš„ next æŒ‡é’ˆæ‰¾åˆ°ç¬¬äºŒä¸ªçˆ¶èŠ‚ç‚¹ï¼Œç„¶åŽåœ¨å®ƒä»¬çš„å­©å­ä¹‹é—´å»ºç«‹è¿žæŽ¥ã€‚ 1node.right.next = node.next.left å®Œæˆå½“å‰å±‚çš„è¿žæŽ¥åŽï¼Œè¿›å…¥ä¸‹ä¸€å±‚é‡å¤æ“ä½œï¼Œç›´åˆ°æ‰€æœ‰çš„èŠ‚ç‚¹å…¨éƒ¨è¿žæŽ¥ã€‚è¿›å…¥ä¸‹ä¸€å±‚åŽéœ€è¦æ›´æ–°æœ€å·¦èŠ‚ç‚¹ï¼Œç„¶åŽä»Žæ–°çš„æœ€å·¦èŠ‚ç‚¹å¼€å§‹éåŽ†è¯¥å±‚æ‰€æœ‰èŠ‚ç‚¹ã€‚å› ä¸ºæ˜¯å®Œç¾ŽäºŒå‰æ ‘ï¼Œå› æ­¤æœ€å·¦èŠ‚ç‚¹ä¸€å®šæ˜¯å½“å‰å±‚æœ€å·¦èŠ‚ç‚¹çš„å·¦å­©å­ã€‚å¦‚æžœå½“å‰æœ€å·¦èŠ‚ç‚¹çš„å·¦å­©å­ä¸å­˜åœ¨ï¼Œè¯´æ˜Žå·²ç»åˆ°è¾¾è¯¥æ ‘çš„æœ€åŽä¸€å±‚ï¼Œå®Œæˆäº†æ‰€æœ‰èŠ‚ç‚¹çš„è¿žæŽ¥ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public Node connect(Node root) &#123; if (root == null) &#123; return root; &#125; // Start with the root node. There are no next pointers // that need to be set up on the first level Node leftmost = root; // Once we reach the final level, we are done while (leftmost.left != null) &#123; // Iterate the "linked list" starting from the head // node and using the next pointers, establish the // corresponding links for the next level Node head = leftmost; while (head != null) &#123; // CONNECTION 1 head.left.next = head.right; // CONNECTION 2 if (head.next != null) &#123; head.right.next = head.next.left; &#125; // Progress along the list (nodes on the current level) head = head.next; &#125; // Move onto the next level leftmost = leftmost.left; &#125; return root; &#125;&#125; ps:æŽ’ç‰ˆçœŸè´¹æ—¶é—´å‘€]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä¸€ä»¶æžç¬‘çš„äº‹]]></title>
    <url>%2F2020%2F04%2F08%2F%E4%B8%80%E4%BB%B6%E6%90%9E%E7%AC%91%E7%9A%84%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[æœ€è¿‘è¿™æ®µæ—¶é—´ä¸€ç›´åœ¨æŠ¢èŒ…å°ï¼Œæ˜¯æƒ³ç€ä»¥åŽåŽ»TXHå®¶ä¸Šé—¨æäº²çš„æ—¶å€™èƒ½ç”¨ä¸Šï¼Œå†åŠ ä¸¤æ¡ä¸­åŽï¼Œæ„Ÿè§‰æŒºéš†é‡çš„äº†ã€‚è€Œä¸”ä¸ºäº†èƒ½æœ‰èµ„æ ¼è´­ä¹°ï¼Œè¿˜å……äº†äº¬ä¸œplusï¼Œå¤©çŒ«ä¼šå‘˜ï¼Œ88ä¼šå‘˜ï¼ŒèŠ±äº†ä¸å°‘é’±å’Œæ—¶é—´ï¼Œç»“æžœé…’è¿˜æ²¡æŠ¢åˆ°ï¼Œæˆ‘äººå·²ç»è¦å—ä¸äº†å¥¹äº†ã€‚ ä¹‹å‰æˆ‘å†™çš„ç§»æ°‘è®¡åˆ’é‡Œé¢ä¹Ÿæœ‰TXHçš„éƒ¨åˆ†ï¼Œä¸€ç›´éƒ½æƒ³é—®å¥¹æœ‰æ²¡æœ‰ç§»æ°‘çš„æƒ³æ³•æ¥ç€ã€‚å› ä¸ºæˆ‘è§‰å¾—æˆ‘ä»¬ä¸‰è§‚è¿˜æŒºåˆï¼Œè¯´ä¸å®šå¥¹ä¹Ÿæƒ³ç¦»å¼€è¿™ä¸ªå¤§ç²ªå‘ã€‚å¦‚æžœæœ‰è¿™ä¸ªæƒ³æ³•çš„è¯ï¼Œæˆ‘ä»¬å¯ä»¥ä¸€èµ·åŠªåŠ›ï¼Œæˆ‘ä¸»ç”³è€Œå¥¹ä½œä¸ºé…å¶å‰¯ç”³ï¼Œå¯æ˜¯æ¯æ¬¡è·Ÿä»–æ‰“ç”µè¯éƒ½åƒæ¬ äº†å¥¹é’±ä¼¼çš„ï¼Œæˆ‘å°±æ‡’å¾—é—®äº†ã€‚å¯ä»¥è¯´åœ¨æˆ‘åŽŸæœ¬çš„äººç”Ÿè§„åˆ’é‡Œé¢æ˜¯æœ‰å¥¹çš„ï¼Œåªè¦å¥¹èƒ½ç¨å¾®æ­£å¸¸ä¸€ç‚¹ï¼Œå¯æ˜¯å¥¹åšä¸åˆ°ã€‚ ä»Šå¤©è·Ÿå¥¹æŠŠè¯æŒ‘æ˜Žäº†ï¼Œæˆ‘çš„è€å¿ƒæ˜¯æœ‰é™çš„ã€‚ä¼°è®¡å¥¹è¿˜æŒºå¾—æ„ï¼Œè¯´â€œæˆ‘æ—©æ–™åˆ°äº†â€ï¼Œæƒ³ç€è€ƒéªŒæˆ‘ä¸€æ®µæ—¶é—´ï¼Œçœ‹æˆ‘èƒ½åšæŒå¤šä¹…ã€‚ç„¶åŽæˆ‘æ’‚æŒ‘å­äº†ï¼Œä¼°è®¡ä¼šæƒ³â€œæˆ‘å°±çŸ¥é“ä½ åšæŒä¸äº†å¤šä¹…çš„â€ï¼Œâ€œæžœç„¶é—ºèœœè¯´çš„æ²¡é”™â€balabalaçš„ã€‚ å¯¹æ­¤æˆ‘åªèƒ½è¯´åŠ æ²¹ï¼Œç»§ç»­ç›¸ä¿¡ä½ çš„é—ºèœœï¼Œç»§ç»­ä½œå§ï¼Œè¿˜èƒ½ä½œå‡ å¹´ï¼Œé©¬ä¸Šå¥”ä¸‰çš„äººäº†ã€‚ å¯¹äº†ï¼Œé‚£æ¡æœ‹å‹åœˆä½ æœ‰æ²¡æœ‰å‘è¿‡ï¼Œä½ è‡ªå·±æœ€æ¸…æ¥šä¸è¿‡äº†ã€‚ä½ å¯ä»¥éª—æˆ‘ï¼ˆè™½ç„¶éª—ä¸åˆ°å°±æ˜¯äº†ï¼‰ï¼Œä½†æ˜¯ä½ éª—ä¸äº†è‡ªå·±ã€‚äº‹æƒ…æ˜¯ä½ åšçš„ï¼ˆæŒ‡æ‹‰é»‘ï¼‰ï¼Œæœ‹å‹åœˆæ˜¯ä½ å‘çš„ï¼ˆæŒ‡ä½ é‚£æ¡â€œè¿½æˆ‘è¦ä¸»åŠ¨ç‚¹ï¼Œä¸è¦éšä¾¿æ”¾å¼ƒbalabalaâ€çš„æœ‹å‹åœˆï¼‰ï¼Œè¯æ˜¯ä½ è¯´çš„ï¼ˆæŒ‡â€œæˆ‘ä»¬æ˜¯æ™®é€šè€åŒå­¦å…³ç³»â€ï¼‰ï¼Œè€Œæˆ‘åªæ˜¯å¤è¿°ä¸€éï¼Œå°±å˜æˆæˆ‘çš„é”™äº†ï¼Œå¥³äººéƒ½è¿™æ ·å—ï¼Œæˆ‘å·²ç»ä¹ æƒ¯äº†ã€‚ é«˜å‚²å¦‚ä½ ï¼Œå–œæ¬¢ä¸€ä¸ªäººä¹Ÿä¸æ•¢æ‰¿è®¤ï¼Œå¾ˆä¸¢è„¸å—ï¼Ÿæˆ‘ä¼šç¬‘ä½ å—ï¼Ÿèµ°åˆ°ä»Šå¤©è¿™ä¸€æ­¥ï¼Œå®Œå…¨æ˜¯ä½ å’Žç”±è‡ªå–ï¼Œå½“ç„¶æˆ‘ä¹Ÿæœ‰è´£ä»»ã€‚ å°±è¿™æ ·å§ï¼Œå¾—æŠ½ç©ºæŠŠåŽŸæœ¬çš„è§„åˆ’æ”¹æ”¹å’¯ã€‚]]></content>
      <tags>
        <tag>ç”Ÿæ´»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-114 Flatten Binary Tree to Linked List]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-114%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 12345 1 / \ 2 5 / \ \3 4 6 The flattened tree should look like: 12345678910111 \ 2 \ 3 \ 4 \ 5 \ 6 æ€è·¯: â€‹ ä¸€å¼€å§‹è¿˜ä»¥ä¸ºæ˜¯æŠŠæ ‘è½¬æˆLinkedListï¼Œæƒ³ç€è¿˜æŒºç®€å•ï¼Œå¼„ä¸ªå…ˆåºéåŽ†addè¿›åŽ»å°±å®Œäº‹äº†ã€‚åŽæ¥æ‰å‘çŽ°ç†è§£é”™é¢˜æ„äº†ã€‚ ä»£ç : 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private TreeNode prev = null; public void flatten(TreeNode root) &#123; if (root == null)&#123; return; &#125; flatten(root.right); flatten(root.left); root.right = prev; root.left = null; prev = root; &#125;&#125; çœ‹è§è¿™ç§ç‰¹åˆ«çŸ­çš„ä»£ç å°±å¤´ç–¼ï¼Œæ²¡æžæ¸…æ¥šé€’å½’çš„æ‰§è¡Œé¡ºåºï¼Œå¯¼è‡´çœ‹ä¸æ‡‚ã€‚ä»Šå¤©å…ˆä¸åšäº†ï¼Œæ¶ˆåŒ–ä¸€ä¸‹ï¼Œæ²¡å¼„æ‡‚çš„åœ°æ–¹è¿˜å¾ˆå¤šã€‚]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-113 Path Sum II]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-113%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree and a sum, find all root-to-leaf paths where each pathâ€™s sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 1234567 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1 Return: 1234[ [5,4,11,2], [5,8,4,5]] æ€è·¯: â€‹ å’Œä¸Šä¸€é¢˜ç±»ä¼¼ï¼ŒDFSå…ˆåºéåŽ†ï¼Œå»ºä¸€ä¸ªäºŒç»´æ•°ç»„ï¼ŒéåŽ†çš„æ—¶å€™addè¿›åŽ»ï¼Œä½†æ˜¯å…·ä½“ä»£ç å†™ä¸å‡ºæ¥ï¼Œè¿˜æ˜¯ä¼šå¡ä½ã€‚ ä»£ç : 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; current = new ArrayList&lt;Integer&gt;(); return helper(root,sum,result,current); &#125; public List&lt;List&lt;Integer&gt;&gt; helper(TreeNode root,int sum,List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; current)&#123; if (root == null)&#123; return result; &#125; current.add(root.val); if (root.left == null &amp;&amp; root.right == null &amp;&amp; sum == root.val)&#123; result.add(new ArrayList(current)); &#125; helper(root.left,sum -root.val,result,current); helper(root.right,sum -root.val,result,current); current.remove(current.size()-1); return result; &#125;&#125; é€’å½’è¿™å—è¿˜æ˜¯æœ‰äº›è–„å¼±ï¼Œå…¶å®žè¿˜æ˜¯æ²¡èƒ½å½»åº•å¼„æ‡‚é€’å½’çš„åŽŸç†ï¼Œä¸è¿‡æ¯”èµ·å‡ å¤©å‰æœ‰è¿›æ­¥äº†ï¼Œä¹‹å‰è¿žæ€è·¯éƒ½æ²¡æœ‰ã€‚çŽ°åœ¨å¥½æ­¹æœ‰æ€è·¯äº†ï¼Œåªæ˜¯å†™ä¸å‡ºæ¥ã€‚]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-112 Path Sum]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-112%2F</url>
    <content type="text"><![CDATA[Level: Easy Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 1234567 5 / \ 4 8 / / \ 11 13 4 / \ \7 2 1 return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 123456789101112131415161718/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if(root == null) return false; if(root.left == null &amp;&amp; root.right == null) return sum == root.val; return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); &#125;&#125; ä¸ºå•¥æœ‰æ—¶å€™Easyçš„é¢˜ç›®ä¹Ÿåšä¸å‡ºæ¥ã€‚]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-111 Minimum Depth of Binary Tree]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-111%2F</url>
    <content type="text"><![CDATA[Level: Easy Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its minimum depth = 2. è‡ªå·±çš„è§£ 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int minDepth(TreeNode root) &#123; int depth = 1; if (root == null)&#123; return 0; &#125; return helper(root,depth); &#125; public int helper(TreeNode root,int depth)&#123; depth ++; if (root.left != null)&#123; helper(root.left,depth); &#125; if(root.right != null)&#123; helper(root.right,depth); &#125; return depth; &#125;&#125; ç„¶è€Œæ˜¯é”™çš„ã€‚ æ­£ç¡®ç­”æ¡ˆ: 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int minDepth(TreeNode root) &#123; if (root == null)&#123; return 0; &#125; return helper(root); &#125; public int helper(TreeNode root)&#123; if (root.left == null) &#123; return minDepth(root.right) + 1; &#125; if (root.right == null) &#123; return minDepth(root.left) + 1; &#125; return Math.min(minDepth(root.left),minDepth(root.right)) + 1; &#125;&#125; å¤§ä½“æ¡†æž¶ä¸Šæ˜¯å¯¹äº†ï¼Œä½†æ˜¯ç»†èŠ‚è¿˜æ˜¯ä¸å¯¹ï¼Œè¿˜æ˜¯å¾ˆèœã€‚ã€‚ã€‚]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-110 Balanced Binary Tree]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-110%2F</url>
    <content type="text"><![CDATA[Level: Easy Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Example 1: Given the following tree [3,9,20,null,null,15,7]: 12345 3 / \9 20 / \ 15 7 Return true. Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]: 1234567 1 / \ 2 2 / \ 3 3 / \4 4 æ€è·¯: â€‹ ä¸ªäººæƒ³æ³•ï¼ŒDFSç„¶åŽç”¨ä¸€ä¸ªå˜é‡è®°å½•é«˜åº¦ï¼Œçœ‹äº†è¯„è®ºåŒºå‘çŽ°å¹¶æ²¡æœ‰è¿™æ ·çš„å®žçŽ°ã€‚ ä¸ºä»€ä¹ˆéš¾åº¦ä¸ºEasyçš„é¢˜ç›®æˆ‘å´çœ‹ä¸æ‡‚ã€‚ 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isBalanced(TreeNode root) &#123; if(root == null)&#123; return true; &#125; return helper(root) != -1; &#125; private int helper(TreeNode root)&#123; if(root == null)&#123; return 0; &#125; int left = helper(root.left); int right = helper(root.right); if(left == -1 || right == -1 || Math.abs(left - right) &gt; 1)&#123; return -1; &#125; return Math.max(left, right) + 1; &#125;&#125; å¯èƒ½æ˜¯å¯¹é«˜åº¦ä¸ç†Ÿå§ï¼Œç¬¬ä¸€æ¬¡ç¢°è§é«˜åº¦çš„é¢˜ã€‚]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-108 Convert Sorted Array to Binary Search Tree]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-108%2F</url>
    <content type="text"><![CDATA[Level: Easy Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted array: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 æ€è·¯: â€‹ å…ˆæ‰¾å‡ºæ ¹èŠ‚ç‚¹ï¼Œå†åˆ†åˆ«æž„å»ºå·¦å³å­æ ‘ã€‚ç”±äºŽæ˜¯æŽ’åºå¥½çš„Arrayï¼Œé‚£ä¹ˆæ•°ç»„ä¸­é—´çš„æ•°å°±æ˜¯è¿™æ£µæ ‘çš„æ ¹èŠ‚ç‚¹ã€‚int middle = start + (end-start)/2;å’Œint middle = (start+end)/2;åŽä¸€ç§å†™æ³•å¯èƒ½ä¼šé€ æˆinteger overflowï¼Œä¸ºäº†é¿å…è¿™ä¸ªåº”è¯¥å°½é‡ä½¿ç”¨ç¬¬ä¸€ç§ã€‚ è§£: 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; if (nums.length == 0 || nums == null)&#123; return null; &#125; return helper(nums,0,nums.length -1); &#125; public TreeNode helper(int[] nums, int start, int end)&#123; if (start &gt; end)&#123; return null; &#125; int middle = start + (end-start)/2; TreeNode node = new TreeNode(nums[middle]); node.left = helper(nums, start, middle -1); node.right = helper(nums, middle+1, end); return node; &#125;&#125; å†™æ ‘çš„ç®—æ³•ï¼Œæ¸æ¸çš„æœ‰äº›æ„Ÿè§‰äº†ã€‚]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-107 Binary Tree Level Order Traversal II]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-107%2F</url>
    <content type="text"><![CDATA[Level: Easy Given a binary tree, return the bottom-up level order traversal of its nodesâ€™ values. (ie, from left to right, level by level from leaf to root). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its bottom-up level order traversal as: 12345[ [15,7], [9,20], [3]] ç±»ä¼¼äºŽä¹‹å‰çš„102é¢˜ï¼Œå¥‡æ€ªçš„æ˜¯ï¼Œ102éš¾åº¦ä¸ºMediumï¼Œè€Œè¿™é¢˜éš¾åº¦ä¸ºEasyã€‚ ä¸è¿‡æœ‰ç‚¹è®°ä¸æ¸…ä¹‹å‰çš„æ€è·¯äº†ï¼Œåªè®°å¾—ç”¨äº†Queueï¼Œåˆ©ç”¨Queen FIFOçš„ç‰¹æ€§ã€‚è€Œè¿™é¢˜å¯ä»¥ç”¨Stackï¼ŒLIFOã€‚ ä¸è¿‡Stackæ²¡æ€Žä¹ˆçŽ©è¿‡ï¼Œçœ‹äº†çœ¼è¯„è®ºåŒºï¼Œå‘çŽ°è¿˜æ˜¯ç”¨çš„Queueï¼Œæœ€åŽaddçš„æ—¶å€™ç”¨çš„æ˜¯list.add(0,item);çœ‹åˆ°è¿™ç»ˆäºŽå¼„æ‡‚äº†ä¹‹å‰Zå½¢å±‚æ¬¡éåŽ†äº§ç”Ÿçš„ä¸€ä¸ªç–‘é—®ï¼Œä¹Ÿå°±æ˜¯å½“æ—¶list.add(0,xx);çš„ä½œç”¨ã€‚ä¹‹å‰ä¸€ç›´ä»¥ä¸ºå¦‚æžœaddçš„åœ°æ–¹åŽŸæœ¬æœ‰å€¼ï¼Œä¼šæŠŠåŽŸæ¥çš„å€¼ç»™è¦†ç›–æŽ‰ï¼Œæ‰€ä»¥ä¹‹å‰çœ‹åˆ°çš„æ—¶å€™æ²¡æœ‰æžæ‡‚è¿™ç§å†™æ³•ã€‚ æœ‰ç”¨çš„çŸ¥è¯†å¢žåŠ äº†.jpg è§£: 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (root == null) &#123; return result; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; List&lt;Integer&gt; level = new ArrayList&lt;Integer&gt;(); int level_lengh = queue.size(); for (int i = 0; i &lt; level_lengh; i++) &#123; TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) &#123; queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; &#125; result.add(0, level); &#125; return result; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-106 Construct Binary Tree from Inorder and Postorder Traversal]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-106%2F</url>
    <content type="text"><![CDATA[Level: Medium Given inorder and postorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given 12inorder = [9,3,15,20,7]postorder = [9,15,7,20,3] Return the following binary tree: 12345 3 / \9 20 / \ 15 7 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] inorder, int[] postorder) &#123; if (inorder == null || postorder == null || inorder.length != postorder.length) &#123; return null; &#125; Map&lt;Integer, Integer&gt; inMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; inorder.length; i++) &#123; inMap.put(inorder[i], i); &#125; return buildTreeHelper(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1, inMap); &#125; public TreeNode buildTreeHelper(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd, Map&lt;Integer, Integer&gt; inMap) &#123; if (inStart &gt; inEnd || postStart &gt; postEnd) &#123; return null; &#125; TreeNode root = new TreeNode(postorder[postEnd]); int numerLeft = inMap.get(postorder[postEnd]); root.left = buildTreeHelper(inorder, inStart, numerLeft - 1, postorder, postStart, postStart + numerLeft - inStart - 1, inMap); root.right = buildTreeHelper(inorder, numerLeft + 1, inEnd, postorder, postStart + numerLeft - inStart, postEnd - 1, inMap); return root; &#125; &#125; å¯¹äºŽå·¦å³å­æ ‘ç´¢å¼•çš„è®¡ç®—å’Œä¼ å…¥è¿˜æœ‰äº›å›°æƒ‘ï¼Œä¾‹å¦‚ 1postStart + numerLeft - inStart - 1 å’Œ 1postStart + numerLeft - inStart ä¸‹æ¬¡å†åšä¸€éï¼ŒåŠ æ·±ç†è§£ã€‚]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 105 Construct Binary Tree from Preorder and Inorder Traversal]]></title>
    <url>%2F2020%2F04%2F03%2FLeetCode-105%2F</url>
    <content type="text"><![CDATA[Level: Medium Construct Binary Tree from Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given 12preorder = [3,9,20,15,7]inorder = [9,3,15,20,7] Return the following binary tree: 12345 3 / \9 20 / \ 15 7 æ€è·¯ï¼š â€‹ æ²¡æœ‰ é˜…è¯»ç†è§£ æ–¹æ³•1 12345678910111213141516171819public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return helper(0, 0, inorder.length - 1, preorder, inorder);&#125;public TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) &#123; if (preStart &gt; preorder.length - 1 || inStart &gt; inEnd) &#123; return null; &#125; TreeNode root = new TreeNode(preorder[preStart]); int inIndex = 0; // Index of current root in inorder for (int i = inStart; i &lt;= inEnd; i++) &#123; if (inorder[i] == root.val) &#123; inIndex = i; &#125; &#125; root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder); root.right = helper(preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder); return root;&#125; æ–¹æ³•2 1234567891011121314151617181920212223public TreeNode buildTree(int[] preorder, int[] inorder) &#123; Map&lt;Integer, Integer&gt; inMap = new HashMap&lt;Integer, Integer&gt;(); for(int i = 0; i &lt; inorder.length; i++) &#123; inMap.put(inorder[i], i); &#125; TreeNode root = buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, inMap); return root;&#125;public TreeNode buildTree(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd, Map&lt;Integer, Integer&gt; inMap) &#123; if(preStart &gt; preEnd || inStart &gt; inEnd) return null; TreeNode root = new TreeNode(preorder[preStart]); int inRoot = inMap.get(root.val); int numsLeft = inRoot - inStart; root.left = buildTree(preorder, preStart + 1, preStart + numsLeft, inorder, inStart, inRoot - 1, inMap); root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd, inorder, inRoot + 1, inEnd, inMap); return root;&#125; æ–¹æ³•3 12345678910111213141516171819 public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if(preorder.length!=inorder.length) return null; return build(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1);&#125;public TreeNode build(int [] preorder, int preLow, int preHigh, int[] inorder, int inLow, int inHigh)&#123; if(preLow&gt;preHigh || inLow&gt;inHigh) return null; TreeNode root = new TreeNode(preorder[preLow]); int inorderRoot = inLow; for(int i=inLow;i&lt;=inHigh;i++)&#123; if(inorder[i]==root.val)&#123; inorderRoot=i; break; &#125; &#125; int leftTreeLen = inorderRoot-inLow; root.left = build(preorder, preLow+1, preLow+leftTreeLen, inorder, inLow, inorderRoot-1); root.right = build(preorder, preLow+leftTreeLen+1, preHigh, inorder, inorderRoot+1, preHigh); return root; &#125; è¿™å‡ ä¸ªæ–¹æ³•æ€è·¯æ˜¯ä¸€æ ·çš„ï¼ŒåŒºåˆ«åœ¨äºŽèŽ·å–ä¸­åºéåŽ†rootä½äºŽæ•°ç»„ä¸­çš„indexçš„æ–¹æ³•ä¸åŒï¼Œä¸€ä¸ªç”¨äº†éåŽ†ï¼Œä¸€ä¸ªç”¨äº†HashMapï¼Œå½“ç„¶å‡ ä¸ªéƒ½æœ‰ä¸€ä¸ªå…±åŒçš„å‰æï¼Œæ•°ç»„é‡Œæ²¡æœ‰é‡å¤çš„æ•°ã€‚ çœ‹äº†å¾ˆä¹…çš„ä»£ç ï¼Œå¤§è‡´ä¸Šæ˜Žç™½äº†ï¼Œæ€»çš„æ€è·¯å¦‚ä¸‹: å‰åºéåŽ†çš„ç¬¬ä¸€ä½ä¸€å®šæ˜¯æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œæ ¹æ®è¿™ä¸ªç‰¹æ€§æˆ‘ä»¬å¯ä»¥çŸ¥é“è¿™æ£µæ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œè¿›ä¸€æ­¥å¯ä»¥çŸ¥é“ä¸­åºæ•°ç»„ä¸­æ ¹èŠ‚ç‚¹çš„ä½ç½®ã€‚ ä¸­åºéåŽ†çš„ç‰¹ç‚¹æ˜¯æ ¹èŠ‚ç‚¹å·¦è¾¹ä¸ºå·¦å­æ ‘ï¼Œå³è¾¹ä¸ºå³å­æ ‘ã€‚ ç»“åˆè¿™ä¸¤ç‚¹å¯ä»¥çŸ¥é“è¿™æ£µæ ‘å·¦å³èŠ‚ç‚¹çš„æ•°é‡ã€‚ æ‰¾åˆ°å„ä¸ªå­æ ‘çš„æ ¹èŠ‚ç‚¹ root æž„å»ºè¯¥æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘ æž„å»ºè¯¥æ ¹èŠ‚ç‚¹çš„å³å­æ ‘ è‡ªä»¥ä¸ºçœ‹æ‡‚äº†ï¼ŒåŽ»åš106ï¼Œç»“æžœåšåˆ°å…³é”®åœ°æ–¹è¿˜æ˜¯å¡ä½äº†ï¼Œä¸çŸ¥é“æ˜¯åº”è¯¥åŠ è¿˜æ˜¯å‡ï¼Œè¯´æ˜Žè¿˜æ˜¯æ²¡å®Œå…¨æžæ‡‚ï¼Œå…ˆæ¶ˆåŒ–ä¸€ä¸‹ï¼Œæ˜Žå¤©å†åš106å§ã€‚]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-104 Maximum Depth of Binary Tree]]></title>
    <url>%2F2020%2F04%2F02%2FLeetCode-104%2F</url>
    <content type="text"><![CDATA[Maximum Depth of Binary Tree Level: Easy Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its depth = 3. æ€è·¯: â€‹ è¿™é¢˜æ¯”è¾ƒç®€å•ï¼Œç”¨é€’å½’å®žçŽ°ï¼Œä¸­é€”æƒ³åƒå¹³å¸¸çš„DFSä¸€æ ·ç›´æŽ¥returnï¼Œæƒ³äº†æƒ³å‘çŽ°ä¸è¡Œï¼Œç„¶åŽå¡äº†ä¼šã€‚å¾—æŠŠå·¦å³éƒ½ç®—å‡ºæ¥ï¼Œæ¯”è¾ƒä¸€ä¸‹ï¼Œæ·±åº¦å†åŠ 1ã€‚ 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if (root == null)&#123; return 0; &#125; int left = 0; int right = 0; if (root.left != null)&#123; left = maxDepth(root.left); &#125; if (root.right != null)&#123; right = maxDepth(root.right); &#125; return left&gt;=right?left+1:right+1; &#125;&#125; æ€»ä½“å†™ä¸‹æ¥è¿˜æ¯”è¾ƒé¡ºï¼Œæ²¡ç”¨ideaï¼Œé¡µé¢é‡Œçº¯æ‰‹å†™ï¼Œä¸€æ¬¡ç¼–è¯‘è¿è¡Œé€šè¿‡ã€‚è™½ç„¶æ˜¯ä¸ªEasyéš¾åº¦çš„é¢˜ç›®ï¼Œä½†è¿˜æ˜¯èƒ½æ„Ÿå—åˆ°å› ä¸ºè¿›æ­¥å¸¦æ¥çš„å°å°çš„æˆå°±æ„Ÿã€‚ æäº¤å®Œï¼Œç…§æ—§çœ‹äº†ä¸‹è®¨è®ºåŒºã€‚å‘çŽ°åˆ«äººåªè¦ä¸€è¡Œå°±å®žçŽ°äº†ï¼Œæ·¦ã€‚ 1234567public class Solution &#123; public int maxDepth(TreeNode root) &#123; return root==null? 0 : Math.max(maxDepth(root.left), maxDepth(root.right))+1; &#125;&#125;//https://leetcode.com/problems/maximum-depth-of-binary-tree/discuss/34216/Simple-solution-using-Java// author:dennyrong çœ‹äº†ä¸‹ï¼Œå¤§è‡´ çš„æ€è·¯æ˜¯ä¸€æ ·çš„ã€‚ä¸‰å…ƒè¿ç®—ç¬¦æˆ‘ä¹Ÿç”¨åˆ°äº†ï¼Œåªä¸è¿‡çœŸæ²¡æƒ³è¿‡ç”¨Math.max()è¿™ä¸ªå‡½æ•°ï¼Œè¿˜æ˜¯å¾—ç»§ç»­åŠªåŠ›å‘€ã€‚]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-103 Binary Tree Zigzag Level Order Traversal]]></title>
    <url>%2F2020%2F04%2F02%2FLeetCode-103%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree, return the level order traversal of its nodesâ€™ values. (ie, from left to right, level by level). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] æ€è·¯: â€‹ é¢˜ç›®çš„éœ€æ±‚è·Ÿ102é¢˜å¾ˆç›¸ä¼¼ï¼Œç¬¬ä¸€ååº”å°±æ˜¯å…ˆç…§ç€102å†™ï¼Œç„¶åŽåœ¨è¿™ä¸ªåŸºç¡€ä¹‹ä¸Šæ”¹æ”¹ã€‚ä¸»è¦æ˜¯æƒ³ç€æ”¹ä¸‹é¢è¿™ä¸€æ®µï¼Œå·¦æ”¹å³ï¼Œå³æ”¹å·¦ä¹‹ç±»çš„ã€‚ 123456if (node.left != null) &#123; queue.add(node.left);&#125;if (node.right != null) &#123; queue.add(node.right);&#125; è€Œç„¶æ”¹äº†åŠå¤©ï¼Œå‘çŽ°åšä¸åˆ°é¢˜ç›®è¦æ±‚çš„æ•ˆæžœã€‚äºŽæ˜¯ä¹Žåˆæ±‚åŠ©è¯„è®ºåŒºã€‚æžœç„¶åœ¨åŽŸæœ‰çš„åŸºç¡€ä¸ŠåŠ äº†ä¸ªæ ‡å¿—ä½ï¼Œå¹¶ä¸”æ–°å¢žäº†ä¸€æ®µ 123456if (zigzag) &#123; level.add(0, node.val);&#125;else &#123; level.add(node.val);&#125; è¿™ä¸ªä»£ç åŽï¼Œå°±èƒ½ç¬¦åˆé¢˜ç›®çš„è¦æ±‚äº†ï¼Œå’Œæˆ‘å¿ƒé‡Œçš„é¢„æœŸæ˜¯ç›¸ç¬¦çš„ã€‚ ä½†æ˜¯æ²¡çœ‹æ‡‚è¿™ä¸€æ®µçš„æ„ä¹‰ï¼Œå°±åŽ»äº†leetcode cnï¼Œå¸Œæœ›èƒ½æ‰¾ä¸ªä¸­æ–‡çš„æ€è·¯çœ‹ä¸‹ã€‚ç»“æžœè®©æˆ‘æ²¡æƒ³åˆ°çš„æ˜¯ï¼ŒåŠ›æ‰£ä¸­å›½è¿™é¢˜çš„å†™æ³•å±…ç„¶å®Œå…¨æ¢äº†ä¸€ç§æ€è·¯ã€‚å±žå®ž8è¡Œã€‚]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-102 Binary Tree Level Order Traversal]]></title>
    <url>%2F2020%2F04%2F02%2FLeetCode-102%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree, return the level order traversal of its nodesâ€™ values. (ie, from left to right, level by level). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] æ€è·¯: â€‹ å±‚æ¬¡éåŽ†ã€‚ â€‹ ç„¶è€Œä¸ä¼šå†™å±‚æ¬¡éåŽ†ï¼ŒäºŽæ˜¯ç›´å¥”è¯„è®ºåŒºï¼Œæ‰¾äº†ä¸ªæœ€é«˜èµžçš„ç­”æ¡ˆçœ‹äº†çœ‹ï¼Œå¤§è‡´ä¸Šçœ‹æ‡‚äº†ã€‚ ç®—æ³•ä¸Šé¢çš„é€’å½’æ–¹æ³•ä¹Ÿå¯ä»¥å†™æˆè¿­ä»£çš„å½¢å¼ã€‚æˆ‘ä»¬å°†æ ‘ä¸Šé¡¶ç‚¹æŒ‰ç…§å±‚æ¬¡ä¾æ¬¡æ”¾å…¥é˜Ÿåˆ—ç»“æž„ä¸­ï¼Œé˜Ÿåˆ—ä¸­å…ƒç´ æ»¡è¶³ FIFOï¼ˆå…ˆè¿›å…ˆå‡ºï¼‰çš„åŽŸåˆ™ã€‚åœ¨ Java ä¸­å¯ä»¥ä½¿ç”¨ Queue æŽ¥å£ä¸­çš„ LinkedListå®žçŽ°ã€‚åœ¨ Python ä¸­å¦‚æžœä½¿ç”¨ Queue ç»“æž„ï¼Œä½†å› ä¸ºå®ƒæ˜¯ä¸ºå¤šçº¿ç¨‹ä¹‹é—´å®‰å…¨äº¤æ¢è€Œè®¾è®¡çš„ï¼Œæ‰€ä»¥ä½¿ç”¨äº†é”ï¼Œä¼šå¯¼è‡´æ€§èƒ½ä¸ä½³ã€‚å› æ­¤åœ¨ Python ä¸­å¯ä»¥ä½¿ç”¨ deque çš„ append() å’Œ popleft() å‡½æ•°æ¥å¿«é€Ÿå®žçŽ°é˜Ÿåˆ—çš„åŠŸèƒ½ã€‚ç¬¬ 0 å±‚åªåŒ…å«æ ¹èŠ‚ç‚¹ root ï¼Œç®—æ³•å®žçŽ°å¦‚ä¸‹ï¼šåˆå§‹åŒ–é˜Ÿåˆ—åªåŒ…å«ä¸€ä¸ªèŠ‚ç‚¹ root å’Œå±‚æ¬¡ç¼–å· 0 ï¼š level = 0ã€‚å½“é˜Ÿåˆ—éžç©ºçš„æ—¶å€™ï¼šåœ¨è¾“å‡ºç»“æžœ levels ä¸­æ’å…¥ä¸€ä¸ªç©ºåˆ—è¡¨ï¼Œå¼€å§‹å½“å‰å±‚çš„ç®—æ³•ã€‚è®¡ç®—å½“å‰å±‚æœ‰å¤šå°‘ä¸ªå…ƒç´ ï¼šç­‰äºŽé˜Ÿåˆ—çš„é•¿åº¦ã€‚å°†è¿™äº›å…ƒç´ ä»Žé˜Ÿåˆ—ä¸­å¼¹å‡ºï¼Œå¹¶åŠ å…¥ levels å½“å‰å±‚çš„ç©ºåˆ—è¡¨ä¸­ã€‚å°†ä»–ä»¬çš„å­©å­èŠ‚ç‚¹ä½œä¸ºä¸‹ä¸€å±‚åŽ‹å…¥é˜Ÿåˆ—ä¸­ã€‚è¿›å…¥ä¸‹ä¸€å±‚ level++ã€‚ å®žçŽ° 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (root == null) return levels; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); int level = 0; while ( !queue.isEmpty() ) &#123; // start the current level levels.add(new ArrayList&lt;Integer&gt;()); // number of elements in the current level int level_length = queue.size(); for(int i = 0; i &lt; level_length; ++i) &#123; TreeNode node = queue.remove(); // fulfill the current level levels.get(level).add(node.val); // add child nodes of the current level // in the queue for the next level if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); &#125; // go to next level level++; &#125; return levels; &#125;&#125;/*** https://leetcode-cn.com/problems/binary-tree-level-order-* traversal/solution/er-cha-shu-de-ceng-ci-bian-li-by-leetcode/*/ æ–¹æ³•2: 123456789101112131415161718192021222324List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; List&lt;Integer&gt; level = new ArrayList&lt;&gt;(); int cnt = queue.size(); for (int i = 0; i &lt; cnt; i++) &#123; TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) &#123; queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; &#125; res.add(level); &#125; return res;/*** https://leetcode.com/problems/binary-tree-level-order-* traversal/discuss/33450/Java-solution-with-a-queue-used*/]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-101 Symmetric Tree Easy]]></title>
    <url>%2F2020%2F04%2F01%2FLeetCode-101%2F</url>
    <content type="text"><![CDATA[Symmetric Tree Level:Easy é¢˜ç›®: Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 12345 1 / \ 2 2 / \ / \3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 12345 1 / \2 2 \ \ 3 3 Note:Bonus points if you could solve it both recursively and iteratively. æ€è·¯ï¼Œè¿­ä»£åˆ¤æ–­ç¬¬ä¸€å±‚æ˜¯å¦ä¸ºç©ºï¼Œç¬¬äºŒå±‚å·¦å³èŠ‚ç‚¹æ˜¯å¦ç›¸ç­‰ï¼Œç¬¬ä¸‰å±‚å·¦å­æ ‘çš„å·¦èŠ‚ç‚¹æ˜¯å¦ç­‰äºŽå³å­æ ‘çš„å³èŠ‚ç‚¹ï¼Œå¹¶ä¸”å·¦å­æ ‘çš„å³èŠ‚ç‚¹æ˜¯å¦ç­‰äºŽå³å­æ ‘çš„å·¦èŠ‚ç‚¹ã€‚ å®Œæ•´ä»£ç : 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if (root == null) &#123; return true; &#125; return helper(root.left, root.right); &#125; public boolean helper(TreeNode left, TreeNode right) &#123; if (left == null || right == null) &#123; return left == right; &#125; if (left.val != right.val) &#123; return false; &#125; return helper(left.left, right.right) &amp;&amp; helper(left.right, right.left); &#125;&#125; å¤ªå†¤äº†ï¼Œä»Šå¤©å¤ä¹ çš„æ—¶å€™root == nullæˆ‘return falseï¼Œsubmitçš„æ—¶å€™é‡åˆ°test case: []å±…ç„¶ç®—æˆ‘é”™äº†ï¼ŒæŒ‰é¢˜æ„nullçš„æ—¶å€™åº”è¯¥è¿”å›žtureï¼Œå¤ªæ‰¯äº†ï¼Œç©ºçš„æ ‘ä¹Ÿç®—å¯¹ç§°çš„å—ï¼Ÿå› ä¸ºè¿™ä¸ªé™ä½Žäº†acceptçŽ‡å¤ªäºäº†ã€‚ å¤ä¹ : Time Submitted Status Runtime Memory Language 4 minutes ago Accepted 1 ms 39.2 MB java 5 minutes ago Wrong Answer N/A N/A java 8 days ago Accepted 0 ms 37.7 MB java 9 days ago Accepted 0 ms 38 MB java Last update time: 2020å¹´4æœˆ10æ—¥ 15ç‚¹19åˆ†]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-100 Same Tree]]></title>
    <url>%2F2020%2F04%2F01%2FLeetCode-100%2F</url>
    <content type="text"><![CDATA[Same Tree Level:Easy é¢˜ç›®: Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: 1234567Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]Output: true Example 2: 1234567Input: 1 1 / \ 2 2 [1,2], [1,null,2]Output: false Example 3: 1234567Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2]Output: false è§£ç­”: è„‘æµ·é‡Œçš„ç¬¬ä¸€ä¸ªæƒ³æ³•å°±æ˜¯éåŽ†ä¸¤æ£µæ ‘ï¼Œç„¶åŽæ¯”è¾ƒç›¸åŒèŠ‚ç‚¹çš„å¤§å°ï¼Œä½†å‡¡æœ‰ä¸€ä¸ªä¸ç›¸ç­‰å°±è¯´æ˜Žä¸æ˜¯åŒæ ·çš„æ ‘ã€‚å…·ä½“æ€è·¯: é¦–å…ˆåˆ¤æ–­ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦ä¸ºç©º 123456if(p==null&amp;&amp;q==null)&#123; return true;&#125;if(p!=null||q!=null)&#123; return false;&#125; ç„¶åŽå¯¹æ¯”æ ¹èŠ‚ç‚¹rootï¼Œæ ¹èŠ‚ç‚¹ä¸åŒç›´æŽ¥è¿”å›žfalseï¼Œæ ¹èŠ‚ç‚¹ç›¸åŒå†åˆ¤æ–­å·¦å³å­èŠ‚ç‚¹ã€‚ 12345if(p.val==q.val)&#123; return isSameTree(p.left==q.left)&amp;&amp;isSameTree(p.right==q.right);&#125;else&#123; return false;&#125; å®Œæ•´ä»£ç  123456789101112131415161718192021/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if (p == null || q == null) &#123; return (p==q); &#125; if (p.val == q.val) &#123; return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); &#125; else &#123; return false; &#125; &#125;&#125; å¤ä¹ : Time Submitted Status Runtime Memory Language a few seconds ago Accepted 0 ms 36.9 MB java 9 days ago Accepted 0 ms 37.5 MB java Last update time : 2020å¹´4æœˆ10æ—¥ 14ç‚¹50åˆ† 9å¤©å‰ï¼Œè§£æ³•å·²ç»æœ‰äº›æ¨¡ç³Šäº†ï¼Œå‹‰å‹‰å¼ºå¼ºå†™å‡ºäº†ä¸ªæ¡†æž¶ï¼Œä½†æ˜¯æ²¡å¼„é€šè¿‡ã€‚]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç§»æ°‘è®¡åˆ’]]></title>
    <url>%2F2020%2F04%2F01%2F%E7%A7%BB%E6%B0%91%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[ç§»æ°‘ åŠ æ‹¿å¤§ ç§»æ°‘å¿«é€Ÿé€šé“ Express EntryåŸºæœ¬è¦æ±‚ æ‰“ç®—å±…ä½åœ¨é­åŒ—å…‹ä»¥å¤–çš„çœä»½ï¼› è¿‡åŽ»10å¹´å†…ï¼Œæœ‰å¸¦è–ªçš„ã€ä¸€å¹´ä»¥ä¸Šçš„è¿žç»­çš„å…¨èŒï¼ˆæˆ–ç­‰åŒçš„å…¼èŒï¼‰å·¥ä½œï¼Œä»Žäº‹åŒä¸€ä¸ªèŒä¸šï¼Œåœ¨NOC 0ï¼ŒAæˆ–è€…Bç±»åˆ«ä¸­ï¼› è‹±è¯­æˆ–æ³•è¯­è‡³å°‘è¾¾åˆ°CLB 7çº§ï¼ˆé›…æ€4ä¸ª6ï¼‰ï¼› å…­é¡¹æ‰“åˆ†è¶…è¿‡67ã€‚ å¹´é¾„: 27(30å²ä¸€ä¸‹æœ€é«˜åˆ†) 12åˆ†å­¦åŽ†: æœ¬ç§‘ 21åˆ†(åšå£«25(æ»¡åˆ†),ç¡•å£«23(çœ‹èƒ½ä¸èƒ½å¼„ä¸ªç¡•å£«å­¦ä½))é›…æ€: 6/6/6/6 16åˆ†å·¥ä½œ: 5 å¹´ 13åˆ†(æ»¡åˆ†15 6å¹´)å•èº«: 0æ€»: 62åˆ†æ•°ä¸å¤Ÿå…¥æ± ,é™¤éžæ‰¾ä¸ªå¥³æœ‹å‹æˆ–è€…é›…æ€7 è”é‚¦æŠ€æœ¯ç§»æ°‘ Federal Skilled Workersæ€»åˆ†336å·®çš„å¤ªå¤š å®‰çœä¼˜æ‰è®¡åˆ’ â€“ å¿«é€Ÿé€šé“NSNPæ–°æ–¯ç§‘èˆçœæåç§»æ°‘é¡¹ç›® - NSNPç´§ç¼ºèŒä¸šEEç±»åˆ« - Catogory Bä¸éœ€è¦é›‡ä¸»offer SINPè¨çœæåç§»æ°‘é¡¹ç›® - 2019- è¨çœæ— é›‡ä¸»æŠ€æœ¯ç§»æ°‘é¡¹ç›® SINP æŠ€æœ¯ç§»æ°‘EEç±»åˆ«ï¼ˆInternational Skilled Worker: Saskatchewan Express Entryï¼‰ SINP æŠ€æœ¯ç§»æ°‘OIDç±»åˆ«ï¼ˆInternational Skilled Worker: Occupation In-Demandï¼‰ SINP EEç±»åˆ«ç”³è¯·æ¡ä»¶ - é£žå‡ºå›½SINPæŠ€æœ¯ç§»æ°‘EEç±»åˆ«è¦æ±‚ç”³è¯·äººçš„èŒä¸šåœ¨è¨çœç´§ç¼ºèŒä¸šåˆ—è¡¨å½“ä¸­ï¼Œé¦–å…ˆéœ€æ»¡è¶³è”é‚¦æŠ€æœ¯ç§»æ°‘67åˆ†è¯„åˆ†æ ‡å‡†è¿›å…¥EEæ± ï¼Œè¿™ä¹Ÿå°±æ„å‘³ç€è¯¥ç±»ç”³è¯·äººé›…æ€éœ€è¦è¾¾åˆ°4ä¸ª6çš„æˆç»©ï¼ŒåŒæ—¶è¿˜éœ€æ»¡è¶³SINPè¯„åˆ†60åˆ†çš„æ ‡å‡†ã€‚ æˆåŠŸåˆ›å»ºEEï¼Œå¹¶è¿›å…¥EEå€™é€‰æ± ï¼ŒèŽ·å¾—EEè´¦æˆ·å·ç ï¼ˆExpress Entry profile Numberï¼‰å’Œæ±‚èŒéªŒè¯ä»£ç ï¼ˆJob Seeker Validation Codeï¼‰ï¼› èŽ·å¾—SINPè¨çœæŠ€æœ¯ç§»æ°‘è¯„åˆ†æ ‡å‡†100åˆ†ä¸­çš„60åˆ†ï¼› æä¾›æŒ‡å®šè€ƒè¯•æœºæž„å‡ºå…·çš„æœ‰æ•ˆè¯­è¨€è€ƒè¯•æˆç»©ï¼Œè€ƒè¯•æˆç»©åº”ä¸ŽEEè´¦æˆ·ä¸­æ‰€æäº¤çš„æˆç»©ç›¸åŒ¹é…ï¼› å®Œæˆä¸ŽåŠ æ‹¿å¤§æ•™è‚²ä½“ç³»ç›¸åŒ¹é…çš„è‡³å°‘ä¸€å¹´çš„é«˜ç­‰æ•™è‚²ã€åŸ¹è®­æˆ–å­¦å¾’æœŸï¼Œå¹¶èŽ·å¾—æ–‡å‡­ã€è¯ä¹¦æˆ–å­¦ä½ï¼› æµ·å¤–å­¦åŽ†ç”³è¯·äººéœ€é€šè¿‡æŒ‡å®šæœºæž„çš„ECAå­¦åŽ†è®¤è¯ï¼› ç”³è¯·äººçš„ä¸“ä¸šæˆ–å—è®­èŒä¸šå¿…é¡»ç¬¦åˆä»¥ä¸‹æ‰€åˆ—æ¡ä»¶ä¹‹ä¸€ï¼š è¿‡åŽ»10å¹´ä¸­è‡³å°‘1å¹´éžæŠ€å·¥ç±»æœ‰å¿å·¥ä½œç»éªŒï¼› è¿‡åŽ»5å¹´ä¸­è‡³å°‘2å¹´æŠ€å·¥ç±»æœ‰å¿å·¥ä½œç»éªŒï¼›æˆ– è¿‡åŽ»3å¹´ä¸­è‡³å°‘12ä¸ªæœˆåŠ æ‹¿å¤§å·¥ä½œç»éªŒï¼ˆæŠ€å·¥ç±»æˆ–éžæŠ€å·¥ç±»å‡å¯ï¼‰ï¼› èŒä¸šå¿…é¡»åœ¨è¨çœç´§ç¼ºèŒä¸šåˆ—è¡¨å½“ä¸­ï¼Œå¹¶ä¸”å±žäºŽNOC 0ã€Aã€Bç±»ï¼› å¦‚æžœç”³è¯·äººçš„èŒä¸šåœ¨è¨çœä¸ºå—ç®¡åˆ¶èŒä¸šï¼Œåˆ™éœ€é¦–å…ˆé€šè¿‡è¨çœè®¤è¯ï¼Œæ‰èƒ½æäº¤ç§»æ°‘ç”³è¯·ï¼› å…·å¤‡å……è¶³çš„å®‰å®¶èµ„é‡‘åŠå®šå±…è®¡åˆ’ã€‚ SINP OIDç±»åˆ«ç”³è¯·æ¡ä»¶ - é£žå‡ºå›½SINPæŠ€æœ¯ç§»æ°‘OIDç±»åˆ«è¦æ±‚ç”³è¯·äººçš„èŒä¸šåœ¨è¨çœç´§ç¼ºèŒä¸šåˆ—è¡¨å½“ä¸­ï¼Œæ»¡è¶³SINPè¯„åˆ†60åˆ†çš„æ ‡å‡†ï¼Œå…¶ä¸­è¯­è¨€æ‰“åˆ†ä¸ŽEEç±»åˆ«ç•¥æœ‰ä¸åŒï¼ŒOIDç±»åˆ«è¯­è¨€è¾¾åˆ°CLB 4å³å¯å¾—åˆ°12åˆ†åŠ åˆ†ï¼Œè¿™ä¸€æ ‡å‡†ä¸é€‚ç”¨äºŽEEç±»åˆ«ï¼Œå› æ­¤è®¸å¤šé›…æ€æ— æ³•è¾¾åˆ°4ä¸ª6çš„ç”³è¯·äººï¼Œåªè¦å…¶ä»–æ¡ä»¶æ»¡è¶³å³å¯é€šè¿‡è¯¥é€”å¾„ç”³è¯·ç§»æ°‘ã€‚ èŽ·å¾—SINPè¨çœæŠ€æœ¯ç§»æ°‘è¯„åˆ†æ ‡å‡†100åˆ†ä¸­çš„60åˆ†ï¼› è¯­è¨€è‡³å°‘è¾¾åˆ°CLB4ï¼Œé›‡ä¸»å’Œç›‘ç®¡æœºæž„å¯èƒ½ä¼šè¦æ±‚æ›´é«˜çš„è¯­è¨€æˆç»©ï¼› å®Œæˆä¸ŽåŠ æ‹¿å¤§æ•™è‚²ä½“ç³»ç›¸åŒ¹é…çš„è‡³å°‘ä¸€å¹´çš„é«˜ç­‰æ•™è‚²ã€åŸ¹è®­æˆ–å­¦å¾’æœŸï¼Œå¹¶èŽ·å¾—æ–‡å‡­ã€è¯ä¹¦æˆ–å­¦ä½ï¼› æµ·å¤–å­¦åŽ†ç”³è¯·äººéœ€é€šè¿‡æŒ‡å®šæœºæž„çš„ECAå­¦åŽ†è®¤è¯ï¼› è¿‡åŽ»åå¹´å†…å…·å¤‡è‡³å°‘ä¸€å¹´ç›¸å…³å·¥ä½œç»éªŒï¼ŒèŒä¸šç±»åˆ«å±žäºŽNOC 0ã€Aå’ŒBç±»ï¼› å¦‚æžœç”³è¯·äººçš„èŒä¸šåœ¨è¨çœä¸ºå—ç®¡åˆ¶èŒä¸šï¼Œåˆ™éœ€é¦–å…ˆé€šè¿‡è¨çœè®¤è¯ï¼Œæ‰èƒ½æäº¤ç§»æ°‘ç”³è¯·ï¼› å…·å¤‡å……è¶³çš„å®‰å®¶èµ„é‡‘åŠå®šå±…è®¡åˆ’ã€‚ æ‚QSW é­çœï¼Œ20180802åŽå®žæ–½é«˜åˆ†é€‰ï¼Œæ³•è¯­å°†å˜çš„æœ€é‡è¦ï¼Œå…¶æ¬¡æ˜¯é­åŒ—å…‹å­¦åŽ†ä¸”é«˜åˆ†ä¸“ä¸šï¼Œå†æ¬¡æ˜¯æœ‰job offerçš„ï¼Œä¸‰è€…æœ‰2é¡¹ä»¥ä¸Šçš„åŸºæœ¬æ— æ‚¬å¿µã€‚éœ€è¦æ³•è¯­å¥½æˆ–ä¸“ä¸šå¥½ï¼Œæœ€æ–°å—è®­åŠ åˆ†è°ƒæ•´ï¼Œè®¡ç®—æœº,ä¼šè®¡ï¼Œèˆªç©ºèˆªå¤©ï¼Œé“¶è¡Œå’Œé‡‘èžï¼Œç”Ÿç‰©ï¼ŒåœŸæœ¨å»ºç­‘ï¼Œåœ°çƒï¼Œç”µå­ç”µæ°”ï¼Œé£Ÿå“ï¼Œåœ°è´¨ï¼Œæ°´æ–‡ï¼Œæœºæ¢°ï¼ŒæŠ¤ç†ï¼Œç‰©ç†ï¼Œæ¤ç‰©ï¼Œé£Ÿå“åŠ å·¥ç­‰åªæœ‰9åˆ†ã€‚ SINP è¨çœï¼Œ20180716åŽæ”¹ä¸º EOI æ‹©ä¼˜é€‰ï¼Œç¬¬ä¸€æ¬¡é‚€è¯·68åˆ†ï¼Œæœ‰è¨çœäº²å±žï¼Œæœ‰è¨çœç•™å­¦å’Œå·¥ä½œç»éªŒçš„ç”³è¯·äººæ›´å ä¼˜åŠ¿ã€‚åˆ†ä¸ºEEå’ŒOIDï¼ˆéžEEï¼‰ä¸¤ç§ç±»åž‹ï¼Œé›…æ€è¦æ±‚ä½Žï¼Œé€‚åˆå·¥ä½œç»éªŒä¹…çš„ç”³è¯·äººï¼Œçƒ­é—¨ç´§ç¼ºèŒä¸šï¼šå·¥ç¨‹å¸ˆç»ç†ï¼ŒåœŸæœ¨ã€è®¡ç®—æœºè½¯ç¡¬ä»¶å·¥ç¨‹å¸ˆï¼Œå†œä¸šï¼Œå›­æž—ï¼Œç”µå­ç»´ä¿®ï¼Œç»æµŽå­¦å®¶å¯ä»¥ç”³è¯·ï¼› NSNP æ–°çœï¼Œå½“å‰è¿˜æ˜¯æŠ¢é…é¢ï¼Œ2018å¹´åªå¼€æ”¾ä¸€æ¬¡ï¼Œå½“å‰åªæœ‰EEï¼Œæ ¸å¿ƒç´§ç¼ºèŒä¸šï¼šé‡‘èžå®¡è®¡ä¼šè®¡ï¼Œå¹¿å‘Šï¼Œå¸‚åœºï¼Œå…¬å…³ï¼Œè¡Œæ”¿åŠ©ç†ï¼Œè´¢åŠ¡å‡ºçº³ï¼ŒåœŸæœ¨å·¥ç¨‹ï¼ŒæŠ¤å£«ï¼Œå¤§ä¸“é™¢æ ¡è®²å¸ˆï¼Œç¤¾å·¥ï¼ŒæŠ¢é…é¢å·¥ä½œé‡å¤§ï¼Œè€Œä¸”èŒä¸šæ¸…å•å’Œç”³è¯·æµç¨‹è¯´å˜å°±å˜ï¼›å¦å¤–20180802 NS LMP å¢žåŠ äº†ç›´æŽ¥åŽ»EEæ± å­é‡ŒæŒ‘é€‰ç´§ç¼ºèŒä¸šçš„ç±»åˆ«ã€‚ OINP å®‰çœ ï¼Œåˆ†ä¸ºé«˜åˆ†ç±»åˆ«ï¼ˆHCPç±»EEåˆ†æ•°400åˆ†ä»¥ä¸Šæœ‰å¸Œæœ›ï¼Œå¶å°”æœ‰èŒä¸šé™åˆ¶ï¼Œå½“å‰é‚€è¯·åˆ†æ•°åœ¨430åˆ†ä»¥ä¸Šï¼Œ2018å¹´4æœˆåŽæ²¡æœ‰å†é‚€è¯·ï¼‰å’Œæ³•è¯­ç±»åˆ«ï¼ˆæ³•è¯­B2ï¼Œç”³è¯·äººå°‘ï¼Œæ— EEåˆ†æ•°å’Œé…é¢é™åˆ¶ï¼‰ï¼›å®‰çœè®¤å¯å¤§å­¦çš„ç¡•åšå¯ä»¥æ— é›‡ä¸»offerç§»æ°‘ï¼Œé™å®šå­¦æ ¡ï¼Œå­¦åŽ†ï¼Œä¸”éœ€è¦æ¯•ä¸š2å¹´å†…ç”³è¯· NBNP NBçœï¼Œæœ‰ç›´ç³»äº²å±žï¼Œæ³•è¯­å¥½æˆ–å‚åŠ è¿‡å®£è®²ä¼šä¸”èŒä¸šå±žäºŽè®¡ç®—æœºï¼ŒåŽ¨å¸ˆï¼Œé…’åº—é¤é¥®æœåŠ¡ç»ç†ï¼Œä¼šè®¡å‡ºçº³ï¼Œå¥åº·æŠ¤ç†ç»ç†ï¼Œé›¶å”®ä¸»ç®¡ç­‰ï¼Œéœ€è¦æ»¡è¶³åŠ æ‹¿å¤§è”é‚¦EEè¦æ±‚ã€‚ MPNP æ›¼çœï¼Œæœ‰æ›¼çœç´§ç¼ºèŒä¸šå·¥ä½œç»éªŒä¸”ä¸Žæ›¼çœæœ‰ç´§å¯†è”ç³»ï¼ŒåŒ…æ‹¬æ›¼çœæœ‰äº²æˆšæœ‹å‹æ‹…ä¿ï¼Œæœ‰æ›¼çœç•™å­¦ã€å·¥ä½œç»éªŒï¼Œæœ‰æ›¼çœè‡ªå·±çš„EOIè¯„åˆ†ï¼Œï¼Œåˆ†ä¸º EE å’Œ HCPï¼ˆéžEEï¼‰ PEIPNP PEI EE ç±»åˆ«å…è®¸æ— é›‡ä¸»offerï¼Œä½†è¦æ±‚ä¸Ž PEI æœ‰è¾ƒç´§å¯†è”ç³»ï¼Œä¾‹å¦‚PEIå·¥ä½œè¿‡ï¼Œç•™å­¦è¿‡ï¼Œæœ‰äº²å±žï¼Œæœ‰æˆ¿äº§ç­‰ï¼Œéœ€è¦æ»¡è¶³åŠ æ‹¿å¤§è”é‚¦EEè¦æ±‚ æ¾³å¤§åˆ©äºš æŠ€æœ¯ç§»æ°‘ 491]]></content>
      <tags>
        <tag>è®¡åˆ’</tag>
        <tag>ç§»æ°‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é›…æ€å¤‡è€ƒè®¡åˆ’]]></title>
    <url>%2F2020%2F03%2F25%2F%E9%9B%85%E6%80%9D%E5%A4%87%E8%80%83%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[è®¡åˆ’ å‡†å¤‡ iPad Pro è¹²ä¸€ä¸ªæ•™è‚²ä¼˜æƒ  å‰‘æ¡¥é›…æ€çœŸé¢˜9-14? 4-9?4-14? æ­£ç‰ˆå¤ªè´µï¼Œå°½é‡æ”¯æŒæ­£ç‰ˆå§ï¼Œä¸è¡Œå°±ç›—ç‰ˆã€‚ å®‰é™çš„åœ°æ–¹ï¼Œåœ¨é™„è¿‘ç‰©è‰²ä¸€ä¸ªå›¾ä¹¦é¦†ï¼Œå‘¨æœ«æ³¡å›¾ä¹¦é¦†ï¼Œ6æœˆæˆ¿å­åˆ°æœŸï¼Œåˆ°æ—¶å€™è¿˜çš„é‡æ–°æ‰¾ä¸ªã€‚ å›¾ä¹¦é¦†çš„å‡†å¤‡ æ°´æ¯ iPad æ‰‹æœº è€³æœº ä¹¦ ç¬”è®°æœ¬ ç¬” å……ç”µå®ï¼Ÿ åŒ… ä¸€ä¸ªä¸€èµ·å­¦ä¹ çš„å¥³æœ‹å‹ å¹²å‡€çš„ç€è£… æ—¶é—´å®‰æŽ’åˆç†åˆ©ç”¨å·¥ä½œçš„ç©ºä½™æ—¶é—´ï¼Œä¸Šä¸‹ç­çš„é€šå‹¤æ—¶é—´ï¼Œä»¥åŠå‘¨æœ«å’Œå‡æœŸã€‚ä¸Šä¸‹ç­é€šå‹¤æ—¶é—´2ä¸ªå°æ—¶å·¦å³ã€‚åˆ¨åŽ»èµ°è·¯å’Œéª‘è½¦æ‰€èŠ±çš„æ—¶é—´ï¼Œå•åœ¨åœ°é“è½¦åŽ¢é‡Œçš„æ—¶é—´ä¿å®ˆä¼°è®¡æœ‰1å°æ—¶30åˆ†å·¦å³ã€‚ å‘¨æœ«: 9ç‚¹ï¼Œèµ·åºŠï¼ŒåŠä¸ªå°æ—¶æ´—æ¼±ï¼Œåƒæ—©é¤ 9ç‚¹30 å‡ºé—¨ åˆ°å›¾ä¹¦é¦†æ—¶é—´æœªå®š 12ç‚¹åƒé¥­ åˆä¼‘ä¸€å°æ—¶ 1ç‚¹ç»§ç»­ 5ç‚¹åƒæ™šé¥­ ç¦»å¼€æ—¶é—´å¾…å®š æ›´ç»†è‡´çš„å®‰æŽ’å¾…å®šï¼Œæ¯”å¦‚èƒŒå•è¯å¤šå°‘åˆ†é’Ÿï¼Œå†™ä½œå¤šå°‘åˆ†é’Ÿï¼Œå¬åŠ›å¤šå°‘åˆ†é’Ÿã€‚å¾…æ—©æœŸçš„æ‘¸ç´¢å’ŒåŽæœŸçš„è°ƒæ•´ã€‚ è€ƒè™‘æ˜¯å¦åº”è¯¥è®¾ç½®ä¼‘æ¯æ—¥ï¼Œè¿˜æ˜¯è¯´æ¯æ—¥ä½™ä¸‹çš„æ—¶é—´ä½œä¸ºä¼‘æ¯å°±è¶³å¤Ÿäº†ã€‚ ç›®çš„å¬/è¯»/å†™/è¯´ 8/7/7/7æ‰¾ä¸€ä¸ªå¿—åŒé“åˆçš„å¥³æœ‹å‹]]></content>
  </entry>
  <entry>
    <title><![CDATA[ç§»æ°‘ç›¸å…³]]></title>
    <url>%2F2020%2F03%2F24%2F%E7%A7%BB%E6%B0%91%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[å¤§å­¦æ—¶çš„è®¡åˆ’30å²ä¹‹å‰ç§»æ°‘çš„ï¼Œä¸çŸ¥ä¸è§‰åªå‰©5å¹´äº†ï¼Œå†è¿™æ ·æµ‘æµ‘å™©å™©ï¼Œæ„Ÿè§‰å°±å®žçŽ°ä¸äº†äº†ã€‚ è¦å¼€å§‹åšä¸€äº›è¯¦ç»†çš„å‡†å¤‡äº†ï¼Œæš‚å®šè¿™å‡ ä¸ªå›½å®¶(ç‰¹åœ°ä¸åŠ åœ°åŒº) å°æ¹¾ï¼šèžå…¥å¾ˆæ–¹ä¾¿ æ—¥æœ¬ï¼šèŒåœºåŽ‹åŠ›æ¯”è¾ƒå¤§çš„æ ·å­ ç¾Žå›½ï¼šæœ€å‘å¾€ï¼ŒæŠ€æœ¯ç§»æ°‘å¤ªéš¾ï¼Œç§»æ°‘æ”¿ç­–æ”¶ç´§ï¼Œåªèƒ½æƒ³ç€è¿‡åŽ»ç”Ÿä¸ªå­©å­ï¼Œå¸®ä¸‹ä¸€ä»£å¼„ä¸ªç¾Žå›½ç±ã€‚ åŠ æ‹¿å¤§ï¼šå¤©æ°”æœ‰ç‚¹å†·ï¼Œæœ‰ç™¾ä¸‡ç§»æ°‘çš„æ”¿ç­–ã€‚ æ–°è¥¿å…°ï¼šå¬è¯´å››å›½é‡Œæœ€ç®€å•çš„ï¼Œä¼˜åŠ¿æ˜¯å›žå¤´ç­¾ã€‚å¹´é¾„å’ŒèŒä¸šæ˜¯ä¼˜åŠ¿ï¼Œæœ€å¤§çš„é—®é¢˜æ˜¯è‹±è¯­ï¼Œé›…æ€å¾—7ç‚¸æˆ–è€…8ç‚¸ã€‚è®¡åˆ’WHVç­¾è¯è½åœ°ï¼Œæ‰¾å·¥ä½œæ¢é•¿æœŸç­¾è¯ã€‚å¯æƒœ19å¹´åœæ­¢äº†é“¶è•¨ç­¾è¯ï¼Œåˆå°‘äº†ä¸ªæ¸ é“ã€‚ æ¾³å¤§åˆ©äºšï¼šå¥½åƒå¯¹åŽäººä¸å¤ªå‹å¥½ã€‚æ”¿ç­–æ”¶ç´§ï¼ŒEOIåˆ†æ•°è¦æ±‚è¶Šæ¥è¶Šé«˜ã€‚ å¸Œæœ›èƒ½æœ‰ä¸ªä¸€èµ·åŠªåŠ›çš„å¥³æœ‹å‹ï¼Œä¸çŸ¥é“txhæ„¿ä¸æ„¿æ„ç§»æ°‘ã€‚é…å¶è‹±è¯­ä¸é”™ä¹Ÿèƒ½åŠ åˆ†ã€‚]]></content>
  </entry>
  <entry>
    <title><![CDATA[å¿«ä¹å‘¨æœ«]]></title>
    <url>%2F2019%2F12%2F21%2F%E5%BF%AB%E4%B9%90%E5%91%A8%E6%9C%AB%2F</url>
    <content type="text"><![CDATA[æ–¯è¾¾æ‹‰æ–¯è¾¾æ‹‰æ–°è¥¿æ¸¸è®°ç¬¬ä¸ƒå­£ é—²ç€å¹²å˜›å‘¢ RM ç‚Žç‚Žæ¶ˆé˜²é˜Ÿ]]></content>
  </entry>
  <entry>
    <title><![CDATA[çˆ±åœ¨é»Žæ˜Žç ´æ™“å‰]]></title>
    <url>%2F2019%2F08%2F11%2F%E7%88%B1%E5%9C%A8%E9%BB%8E%E6%98%8E%E7%A0%B4%E6%99%93%E5%89%8D%2F</url>
    <content type="text"><![CDATA[ä»¥å‰å¯¹çˆ±æƒ…æœŸå¾…çš„æ—¶å€™çœ‹äº†å¥½å¤šçš„çˆ±æƒ…ç‰‡ï¼Œå°è±¡æ¯”è¾ƒæ·±åˆ»çš„å°±æ˜¯è¿™éƒ¨ã€Šçˆ±åœ¨é»Žæ˜Žç ´æ™“å‰ã€‹ã€‚ å…¶å®žæ˜¯ä¸ªä¸‰éƒ¨æ›²è¿˜æœ‰ã€Šçˆ±åœ¨åˆå¤œé»„æ˜åŽã€‹ã€Šçˆ±åœ¨åˆå¤œé™ä¸´å‰ã€‹ã€‚ è®²ä¸ªä¸¤ä¸ªé™Œç”Ÿäººç›¸é‡ï¼Œç›¸çˆ±ï¼Œåˆ†å¼€ï¼Œå†ç›¸é‡çš„æ•…äº‹ã€‚ ä¸¤ä¸ªäº’ä¸ç›¸è¯†çš„äººç›¸çˆ±ï¼ŒçœŸçš„å¾ˆç¾Žå¥½ã€‚]]></content>
  </entry>
  <entry>
    <title><![CDATA[ç”¨å¿ƒè‰¯è‹¦]]></title>
    <url>%2F2019%2F08%2F10%2F%E7%94%A8%E5%BF%83%E8%89%AF%E8%8B%A6%2F</url>
    <content type="text"><![CDATA[ä½ è¯´ä½  æƒ³è¦é€ƒ]]></content>
  </entry>
  <entry>
    <title><![CDATA[èµ·é£Žäº†]]></title>
    <url>%2F2019%2F08%2F09%2F%E8%B5%B7%E9%A3%8E%E4%BA%86%2F</url>
    <content type="text"><![CDATA[å°é£Žè¦æ¥äº†ï¼Œç¬¬ä¸€æ¬¡ç»åŽ†å°é£Žå‘¢ã€‚]]></content>
  </entry>
  <entry>
    <title><![CDATA[å½¢åŠ¿ä¸å¯¹]]></title>
    <url>%2F2019%2F08%2F06%2F%E5%BD%A2%E5%8A%BF%E4%B8%8D%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[å¯æƒœæ²¡å­˜æ¬¾ï¼Œä¸ç„¶æ¢ç‚¹ç¾Žé‡‘ã€‚ çŽ°ä»Šä¹‹é™…ï¼Œåªèƒ½å­˜ç‚¹ç²®é£Ÿï¼Œæ°´ï¼Œæ—¥å¸¸è¯å“ã€‚]]></content>
  </entry>
  <entry>
    <title><![CDATA[å¥èº«è®°å½•]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%81%A5%E8%BA%AB%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[ä¹°çš„å¥èº«è£…å¤‡åˆ°äº†ï¼Œä»Šå¤©å¼€å§‹å¥èº«ï¼Œè®°å½•ä¸‹èº«æçš„å˜åŒ–ã€‚ 2019-08-06 å¥èº«0å¤©ï¼š ä¸€ä¸ªæœˆåŽå†è®°å½•ä¸€æ¬¡ã€‚ 2019-08-11 å¥èº«ç¬¬ä¸€å¤©]]></content>
  </entry>
  <entry>
    <title><![CDATA[å‰ä»–ç»ƒä¹ ]]></title>
    <url>%2F2019%2F08%2F04%2F%E5%90%89%E4%BB%96%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[2019-08-04 è®¤è¯†å…­çº¿è°±ï¼Œäº†è§£å¼¦å’Œå“ï¼Œç»ƒä¹ ã€Šå°æ˜Ÿæ˜Ÿã€‹ã€‚ 2019-08-04 å¿™åˆ«çš„åŽ»äº†ï¼Œç»ƒä¹ ã€Šå°æ˜Ÿæ˜Ÿã€‹30åˆ†é’Ÿã€‚æ¯å¤©æœ€å°‘1å°æ—¶ï¼Œæ˜Žå¤©è¡¥èµ·æ¥ã€‚]]></content>
  </entry>
  <entry>
    <title><![CDATA[å¥½æƒ³å“­ä¸€åœº]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%A5%BD%E6%83%B3%E5%93%AD%E4%B8%80%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[500ç¯‡ç‰¹è¾‘ ï¼ˆæ— æŒ‘çœ‹å¤šäº†åˆ’æŽ‰]]></title>
    <url>%2F2019%2F07%2F03%2F500%E7%AF%87%E7%89%B9%E8%BE%91%20%EF%BC%88%E6%97%A0%E6%8C%91%E7%9C%8B%E5%A4%9A%E4%BA%86%E5%88%92%E6%8E%89%2F</url>
    <content type="text"><![CDATA[å¹¶æ²¡æœ‰ä»€ä¹ˆè¦è¯´çš„ï¼ŒæŠ½ç©ºæŠŠä»¥å‰å¤ªç›‘çš„åšå®¢ç»™æ›´æ–°æŽ‰æ¯”å¦‚&lt;å››ä¸ª&gt;ï¼Œå…¶å®žè¿˜æŒºæƒ³å†™çš„å°±æ˜¯æ‡’ã€‚ å¥½å¥½è¿˜é’±ï¼Œæ—©ç‚¹è¿˜æ¸…ï¼Œæ—©ç‚¹å›žå®¶ã€‚ å¥½å¥½é”»ç‚¼ï¼Œäº‰å–ç»ƒåˆ°èƒ½ä¸€ðŸ‘Šæ‰“æ­»ä¸ƒä¸ƒã€‚ å®Œã€‚]]></content>
  </entry>
  <entry>
    <title><![CDATA[é¦™æ¸¯åŠ æ²¹ï¼]]></title>
    <url>%2F2019%2F06%2F16%2F%E9%A6%99%E6%B8%AF%E5%8A%A0%E6%B2%B9%EF%BC%81%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[å…³äºŽæ±‚å©š]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%85%B3%E4%BA%8E%E6%B1%82%E5%A9%9A%2F</url>
    <content type="text"><![CDATA[å…³äºŽæ±‚å©šï¼Œæˆ‘ä¹‹å‰æƒ³äº†å¾ˆå¤šï¼Œå‡è±¡çš„å¯¹è±¡æ˜¯ä¸ƒä¸ƒã€‚ ä½†æˆ‘è§‰å¾—æŒ‰ç…§çŽ°åœ¨çš„æƒ…å†µç»§ç»­å‘å±•ä¸‹åŽ»ï¼Œæˆ‘åº”è¯¥ä¼šå’ŒTXHç»“å©šå§ï¼Œä¸‰è§‚æŒºåˆé€‚çš„ï¼Œç›¸å¤„èµ·æ¥å¾ˆèˆ’æœã€‚ ä¹‹æ‰€ä»¥ä»Šå¤©ä¼šçªç„¶æœ‰è¿™è‚¡å†²åŠ¨ï¼Œæ˜¯å› ä¸ºåœ¨YouTubeæ— æ„é—´çœ‹åˆ°ä¸€ä¸ªæ‰‹å·¥åšé’»æˆ’çš„è§†é¢‘ï¼ŒçœŸçš„å¾ˆcoolã€‚ Before After æ—¢ç„¶æˆ‘èƒ½ä¸ºå¥³æœ‹å‹åšç½‘ç«™ï¼Œé‚£æˆ‘ä¹Ÿèƒ½ä¸ºè‡ªå·±æœªæ¥è€å©†åšæ›´å¤šï¼Œå“ªä¸ªå¥³ç”Ÿè¿™ä¹ˆå¹¸è¿å‘¢ã€‚]]></content>
  </entry>
  <entry>
    <title><![CDATA[æ˜¯çœŸçˆ±äº†]]></title>
    <url>%2F2019%2F05%2F13%2F%E6%98%AF%E7%9C%9F%E7%88%B1%E4%BA%86%2F</url>
    <content type="text"><![CDATA[txhæ˜¯çœŸçš„å–œæ¬¢æˆ‘ï¼Œå°±åƒæˆ‘å½“æ—¶é‚£ä¹ˆå“”å“”å“”å“”å“” (æˆ‘ä¸æƒ³è¢«è½¦æ’žæ­» â€œæ‰€ä»¥æ²Ÿé€šå¾ˆé‡è¦â€ï¼Œåªæœ‰æ‡‚çš„äººæ‰æ‡‚ï¼ŒçœŸçš„å–œæ¬¢å¯¹æ–¹æ‰ä¼šè¿™æ ·å’Œå¯¹æ–¹è¯´ï¼Œæ˜¯å¸Œæœ›èƒ½å’Œå¯¹æ–¹æ„Ÿæƒ…å¥½å¥½çš„ï¼Œä¸ä¼šå› ä¸ºè¯¯ä¼šåµæž¶ã€‚ æ›¾å‡ ä½•æ—¶ï¼Œæˆ‘ä¹Ÿå“”å“”å“”å“”ã€‚]]></content>
  </entry>
  <entry>
    <title><![CDATA[æ„Ÿå†’äº†]]></title>
    <url>%2F2019%2F05%2F04%2F%E6%84%9F%E5%86%92%E4%BA%86%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Japan]]></title>
    <url>%2F2019%2F04%2F04%2FJapan%2F</url>
    <content type="text"><![CDATA[å“Ÿåš¯ï¼Œçº¦äº†æœ‹å‹åŽ»æ—¥æœ¬çŽ©ã€‚ é¡ºä¾¿å®Œæˆä¸€èµ·åŽ»æ—¥æœ¬çš„çº¦å®šã€‚ å¾—å…ˆåŽ»åŠžæŠ¤ç…§ï¼Œå’Œç­¾è¯ã€‚ æœŸå¾…ï¼ æœªå®Œå¾…ç»­ã€‚ update 2019-04-07 å¯æƒœï¼Œæ²¡æœ‰å•åã€‚ä¸€ç›´æƒ³è¦ä¸ªå•åæ²¡èˆå¾—ä¹°ï¼Œä»Šå¹´æ˜¯æ²¡æœºä¼šäº†/]]></content>
  </entry>
  <entry>
    <title><![CDATA[æƒ³æ—©ç‚¹ç¦»å¼€]]></title>
    <url>%2F2019%2F02%2F24%2F%E6%83%B3%E6%97%A9%E7%82%B9%E7%A6%BB%E5%BC%80%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[æœ‰ä¸ªç‰¹åˆ«æƒ³å†™çš„]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%9C%89%E4%B8%AA%E7%89%B9%E5%88%AB%E6%83%B3%E5%86%99%E7%9A%84%2F</url>
    <content type="text"><![CDATA[ç•™åˆ°é‡è¦çš„æ—¥å­å§ï¼Œæ¯”å¦‚ç”Ÿæ—¥å†å†™ã€‚ ä»Šå¤©å¾ˆå¼€å¿ƒï¼Œå¶ç„¶çš„æƒ³èµ·ä¸€æ®µå°˜å°çš„å¾€äº‹ã€‚å¾—å¥½å¥½æž„æ€ä¸€ä¸‹ï¼Œå†æ¶¦æ¶¦è‰²ï¼Œäº‰å–å†™çš„ä¼˜ç¾Žä¸€äº›ã€‚]]></content>
  </entry>
  <entry>
    <title><![CDATA[å¥½ç´¯ä¸æƒ³å†™]]></title>
    <url>%2F2019%2F02%2F15%2F%E5%A5%BD%E7%B4%AF%E4%B8%8D%E6%83%B3%E5%86%99%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[çˆ±æƒ…]]></title>
    <url>%2F2019%2F02%2F10%2F%E7%88%B1%E6%83%85%2F</url>
    <content type="text"><![CDATA[è‹¥ä¸æ˜¯å› ä¸ºçˆ±ç€ä½  æ€Žä¹ˆä¼šå¤œæ·±è¿˜æ²¡ç¡æ„ æ¯ä¸ªå¿µå¤´éƒ½å…³æ–¼ä½  æˆ‘æƒ³ä½  æƒ³ä½  å¥½æƒ³ä½  â”€â”€èŽ«æ–‡è”š çˆ±æƒ…]]></content>
      <categories>
        <category>æˆ‘ç‹¬è‡ªç”Ÿæ´»</category>
      </categories>
      <tags>
        <tag>æˆ‘ç‹¬è‡ªç”Ÿæ´»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¼±æ™º]]></title>
    <url>%2F2019%2F02%2F05%2F%E5%BC%B1%E6%99%BA%2F</url>
    <content type="text"><![CDATA[æˆ‘æ˜¯ä¸ªå¼±æ™º]]></content>
  </entry>
  <entry>
    <title><![CDATA[å–é†‰äº†]]></title>
    <url>%2F2019%2F02%2F02%2F%E5%96%9D%E9%86%89%E4%BA%86%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[å›žå®¶]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%9B%9E%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[å›žå®¶äº†ï¼Œä¸æ¥äº† ç›¸äº²ï¼Œç»“å©š]]></content>
      <categories>
        <category>æˆ‘ç‹¬è‡ªç”Ÿæ´»</category>
      </categories>
      <tags>
        <tag>æˆ‘ç‹¬è‡ªç”Ÿæ´»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æƒ³è¦å¹¸ç¦]]></title>
    <url>%2F2019%2F01%2F14%2F%E6%83%B3%E8%A6%81%E5%B9%B8%E7%A6%8F%2F</url>
    <content type="text"><![CDATA[éƒ½è¿™ä¹ˆè‡ªå¾‹äº† æ ‡å‡†å¥½ç”·äººï¼Œæ€Žä¹ˆå°±å¾—ä¸åˆ°å¹¸ç¦å‘¢ã€‚ éš¾é“çœŸçš„è¦å˜æˆåç”·äººï¼Œæ‰ä¼šæœ‰å¥³ç”Ÿæ­»å¿ƒå¡Œåœ°çš„å–œæ¬¢å—ã€‚]]></content>
      <categories>
        <category>æˆ‘ç‹¬è‡ªç”Ÿæ´»</category>
      </categories>
      <tags>
        <tag>æˆ‘ç‹¬è‡ªç”Ÿæ´»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åŠ ç­åˆ°æœ€åŽä¸€ä¸ªäºº]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%8A%A0%E7%8F%AD%E5%88%B0%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[ä¹Ÿç®—æ˜¯éš¾å¾—çš„ç»åŽ†äº†]]></content>
      <categories>
        <category>æˆ‘ç‹¬è‡ªç”Ÿæ´»</category>
      </categories>
      <tags>
        <tag>æˆ‘ç‹¬è‡ªç”Ÿæ´»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å•Šï¼Œå¤±çœ äº†]]></title>
    <url>%2F2019%2F01%2F06%2F%E5%95%8A%EF%BC%8C%E5%A4%B1%E7%9C%A0%E4%BA%86%2F</url>
    <content type="text"><![CDATA[æ‰“å“ˆæ¬  éƒ½ä¸çŸ¥é“æ˜¨å¤©å‡ ç‚¹ç¡ç€çš„ï¼Œå¯èƒ½4ç‚¹ï¼Œå¯èƒ½5ç‚¹ã€‚ å¿ƒé‡ŒèŽ«åçƒ¦èºå‘¢ã€‚]]></content>
      <categories>
        <category>æˆ‘ç‹¬è‡ªç”Ÿæ´»</category>
      </categories>
      <tags>
        <tag>æˆ‘ç‹¬è‡ªç”Ÿæ´»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä¸€æœˆè§„åˆ’]]></title>
    <url>%2F2019%2F01%2F05%2F%E4%B8%80%E6%9C%88%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[æƒ³ä½ çš„ç¬¬ ä¸é‡è¦ï¼Œå’³å’³ å®Œæˆæ‰‹å¤´çš„å·¥ä½œ(åºŸè¯) æ‹¾æŽ‡è‡ªå·± ä¹°ä¸€åŒå–œæ¬¢çš„ðŸ‘Ÿï¼å¥½ä¹…æ²¡ä¹°éž‹äº†ï¼Œä¹°åŒAJ4å§ã€‚ è¡£æœðŸ‘” è£¤å­ðŸ‘– å‰ªå¯¸å¤´ðŸ’‡â€â™‚ï¸ åšæŒç»ƒå­—âœï¸ å¤šå‡ºé—¨èµ°èµ°ä¸è¦å®…äº†ðŸ¶ (éš¾åº¦ï¼šðŸŒŸðŸŒŸðŸŒŸðŸŒŸðŸŒŸ)]]></content>
      <categories>
        <category>ç›¸é‡</category>
      </categories>
      <tags>
        <tag>ç›¸é‡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç­”åº”ä¸çˆ±ä½ ]]></title>
    <url>%2F2018%2F10%2F07%2F%E7%AD%94%E5%BA%94%E4%B8%8D%E7%88%B1%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[è™½ç„¶å¾ˆåŠªåŠ›ç»ƒä¹ ç€å¿˜è®°æˆ‘çš„å¿ƒå´è¿˜æ²¡ç­”åº”å¯ä»¥æ”¾å¼ƒäº†ä½  â”€â”€ç­”åº”ä¸çˆ±ä½  éƒ‘ä¸­åŸº æ˜Žæ˜Žçˆ±å¾ˆæ¸…æ™°å´åˆæŽ¥å—åˆ†ç¦»æˆ‘åªå‰©æ€å¿µçš„æƒåˆ©éš¾è¿‡è¿˜æ¥ä¸åŠçˆ±æ—©å·²èžå…¥å‘¼å¸ä¸å­˜åœ¨çš„å­˜åœ¨å¿ƒåº•è™½ç„¶å¾ˆåŠªåŠ›ç»ƒä¹ ç€å¿˜è®°æˆ‘çš„å¿ƒå´è¿˜æ²¡ç­”åº”å¯ä»¥æ”¾å¼ƒäº†ä½ çœŸçš„å¯¹ä¸èµ·ç­”åº”äº†ä½ ä¸å†çˆ±ä½ æˆ‘å´è¿˜æ²¡ç­”åº”æˆ‘è‡ªå·±æ˜Žæ˜Žçˆ±å¾ˆæ¸…æ™°å´è¦æŽ¥å—åˆ†ç¦»æˆ‘åªå‰©æ€å¿µçš„æƒåˆ©éš¾è¿‡è¿˜æ¥ä¸åŠå°±è®©çˆ±èžå…¥ç©ºæ°”ä¸å­˜åœ¨çš„å­˜åœ¨å¿ƒåº•è¯´å¥½è¦å¿˜è®°åååˆæƒ³èµ·åŽŸæ¥æˆ‘çš„å¿ƒè¿˜æ²¡æœ‰ç­”åº”æ”¾å¼ƒäº†ä½ çœŸçš„å¯¹ä¸èµ·è™½ç„¶æ›¾ç»ç­”åº”äº†ä½ æˆ‘å´è¿˜æ²¡ç­”åº”æˆ‘è‡ªå·±å´åˆå¦‚ä½•çœŸçš„ä¸çˆ±ä½ â”€â”€ç­”åº”ä¸çˆ±ä½  éƒ‘ä¸­åŸº]]></content>
      <categories>
        <category>å¬æ­Œ</category>
      </categories>
      <tags>
        <tag>å¬æ­Œ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ€Žæ ·]]></title>
    <url>%2F2018%2F10%2F06%2F%E6%80%8E%E6%A0%B7%2F</url>
    <content type="text"><![CDATA[å¦‚æžœæˆ‘ä»¬çŽ°åœ¨è¿˜åœ¨ä¸€èµ·ä¼šæ˜¯æ€Žæ ·æˆ‘ä»¬æ˜¯ä¸æ˜¯è¿˜æ˜¯æ·±çˆ±ç€å¯¹æ–¹ â”€â”€æ€Žæ · æˆ´ä½©å¦® æˆ‘è¿™é‡Œå¤©å¿«è¦é»‘äº†é‚£é‡Œå‘¢æˆ‘è¿™é‡Œå¤©æ°”å‡‰å‡‰çš„é‚£é‡Œå‘¢æˆ‘è¿™é‡Œä¸€åˆ‡éƒ½å˜äº†æˆ‘å˜çš„æ‡‚äº‹äº†æˆ‘åˆå¼€å§‹å†™æ—¥è®°äº†è€Œé‚£ä½ å‘¢æˆ‘è¿™é‡Œå¤©å¿«è¦äº®äº†é‚£é‡Œå‘¢æˆ‘è¿™é‡Œå¤©æ°”å¾ˆç‚Žçƒ­é‚£é‡Œå‘¢æˆ‘è¿™é‡Œä¸€åˆ‡éƒ½å˜äº†æˆ‘å˜çš„ä¸å“­äº†æˆ‘æŠŠç…§ç‰‡ä¹Ÿæ”¶èµ·äº†è€Œé‚£ä½ å‘¢å¦‚æžœæˆ‘ä»¬çŽ°åœ¨è¿˜åœ¨ä¸€èµ·ä¼šæ˜¯æ€Žæ ·æˆ‘ä»¬æ˜¯ä¸æ˜¯è¿˜æ˜¯æ·±çˆ±ç€å¯¹æ–¹åƒå¼€å§‹æ—¶é‚£æ ·æ¡ç€æ‰‹å°±ç®—å¤©å¿«äº®æˆ‘ä»¬çŽ°åœ¨è¿˜åœ¨ä¸€èµ·ä¼šæ˜¯æ€Žæ ·æˆ‘ä»¬æ˜¯ä¸æ˜¯è¿˜æ˜¯éšçž’ç€å¯¹æ–¹åƒç»“æŸæ—¶é‚£æ ·æ˜ŽçŸ¥é“ä½ æ²¡æœ‰é”™è¿˜ç¡¬è¦æˆ‘åŽŸè°…æˆ‘è¿™é‡Œå¤©å¿«è¦äº®äº†é‚£é‡Œå‘¢æˆ‘è¿™é‡Œå¤©æ°”å¾ˆç‚Žçƒ­é‚£é‡Œå‘¢æˆ‘è¿™é‡Œä¸€åˆ‡éƒ½å˜äº†æˆ‘å˜çš„ä¸å“­äº†æˆ‘æŠŠç…§ç‰‡ä¹Ÿæ”¶èµ·äº†è€Œé‚£ä½ å‘¢å¦‚æžœæˆ‘ä»¬çŽ°åœ¨è¿˜åœ¨ä¸€èµ·ä¼šæ˜¯æ€Žæ ·æˆ‘ä»¬æ˜¯ä¸æ˜¯è¿˜æ˜¯æ·±çˆ±ç€å¯¹æ–¹åƒå¼€å§‹æ—¶é‚£æ ·æ¡ç€æ‰‹å°±ç®—å¤©å¿«äº®æˆ‘ä»¬çŽ°åœ¨è¿˜åœ¨ä¸€èµ·ä¼šæ˜¯æ€Žæ ·æˆ‘ä»¬æ˜¯ä¸æ˜¯è¿˜æ˜¯éšçž’ç€å¯¹æ–¹åƒç»“æŸæ—¶é‚£æ ·æ˜ŽçŸ¥é“ä½ æ²¡æœ‰é”™è¿˜ç¡¬è¦æˆ‘åŽŸè°…å¦‚æžœæˆ‘ä»¬çŽ°åœ¨è¿˜åœ¨ä¸€èµ·ä¼šæ˜¯æ€Žæ ·æˆ‘ä»¬æ˜¯ä¸æ˜¯è¿˜æ˜¯æ·±çˆ±ç€å¯¹æ–¹åƒå¼€å§‹æ—¶é‚£æ ·æ¡ç€æ‰‹å°±ç®—å¤©å¿«äº®æˆ‘ä»¬çŽ°åœ¨è¿˜åœ¨ä¸€èµ·ä¼šæ˜¯æ€Žæ ·æˆ‘ä»¬æ˜¯ä¸æ˜¯è¿˜æ˜¯éšçž’ç€å¯¹æ–¹åƒç»“æŸæ—¶é‚£æ ·æ˜ŽçŸ¥é“ä½ æ²¡æœ‰é”™è¿˜ç¡¬è¦æˆ‘åŽŸè°…æˆ‘ä¸ä¼šåŽŸè°…æˆ‘æ€Žä¹ˆåŽŸè°…â”€â”€æ€Žæ · æˆ´ä½©å¦®]]></content>
      <categories>
        <category>å¬æ­Œ</category>
      </categories>
      <tags>
        <tag>å¬æ­Œ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é€€åŽ]]></title>
    <url>%2F2018%2F10%2F02%2F%E9%80%80%E5%90%8E%2F</url>
    <content type="text"><![CDATA[æˆ‘çŸ¥é“æˆ‘ä»¬éƒ½æ²¡æœ‰é”™ åªæ˜¯æ”¾æ‰‹ä¼šæ¯”è¾ƒå¥½è¿‡ â”€â”€å‘¨æ°ä¼¦ é€€åŽ å¤©ç©ºç°çš„åƒå“­è¿‡ç¦»å¼€ä½ ä»¥åŽå¹¶æ²¡æœ‰ æ›´è‡ªç”±é…¸é…¸çš„ç©ºæ°”å—…å‡ºæˆ‘ä»¬çš„è·ç¦»ä¸€å¹•é”¥å¿ƒçš„ç»“å±€åƒå‘¼å¸èˆ¬æ— æ³•åœæ¯æŠ½å±‰æ³›é»„çš„æ—¥è®°æ¦¨å¹²äº†å›žå¿†é‚£ç¬‘å®¹ æ˜¯å¤å­£ä½ æˆ‘çš„è¿‡åŽ»è¢«é¡ºæ—¶é’ˆçš„å¿˜è®°ç¼ºæ°§è¿‡åŽçš„çˆ±æƒ…ç²—å¿ƒçš„çœ¼æ³ªæ˜¯å¤šä½™æˆ‘çŸ¥é“ä½ æˆ‘éƒ½æ²¡æœ‰é”™åªæ˜¯å¿˜äº†æ€Žä¹ˆé€€åŽä¿¡èª“æ—¦æ—¦ç»™äº†æ‰¿è¯ºå´è¢«æ—¶é—´æ‰‘äº†ç©ºæˆ‘çŸ¥é“æˆ‘ä»¬éƒ½æ²¡æœ‰é”™åªæ˜¯æ”¾æ‰‹ä¼šæ¯”è¾ƒå¥½è¿‡æœ€ç¾Žçš„çˆ±æƒ…å›žå¿†é‡Œå¾…ç»­å¤©ç©ºç°çš„åƒå“­è¿‡ç¦»å¼€ä½ ä»¥åŽå¹¶æ²¡æœ‰ æ›´è‡ªç”±é…¸é…¸çš„ç©ºæ°”å—…å‡ºæˆ‘ä»¬çš„è·ç¦»ä¸€å¹•é”¥å¿ƒçš„ç»“å±€åƒå‘¼å¸èˆ¬æ— æ³•åœæ¯æŠ½å±‰æ³›é»„çš„æ—¥è®°æ¦¨å¹²äº†å›žå¿†é‚£ç¬‘å®¹ æ˜¯å¤å­£ä½ æˆ‘çš„è¿‡åŽ»è¢«é¡ºæ—¶é’ˆçš„å¿˜è®°ç¼ºæ°§è¿‡åŽçš„çˆ±æƒ…ç²—å¿ƒçš„çœ¼æ³ªæ˜¯å¤šä½™æˆ‘çŸ¥é“ä½ æˆ‘éƒ½æ²¡æœ‰é”™åªæ˜¯å¿˜äº†æ€Žä¹ˆé€€åŽä¿¡èª“æ—¦æ—¦ç»™äº†æ‰¿è¯ºå´è¢«æ—¶é—´æ‰‘äº†ç©ºæˆ‘çŸ¥é“æˆ‘ä»¬éƒ½æ²¡æœ‰é”™åªæ˜¯æ”¾æ‰‹ä¼šæ¯”è¾ƒå¥½è¿‡æœ€ç¾Žçš„çˆ±æƒ…å›žå¿†é‡Œå¾…ç»­æˆ‘çŸ¥é“ä½ æˆ‘éƒ½æ²¡æœ‰é”™åªæ˜¯å¿˜äº†æ€Žä¹ˆé€€åŽä¿¡èª“æ—¦æ—¦ç»™äº†æ‰¿è¯ºå´è¢«æ—¶é—´æ‰‘äº†ç©ºæˆ‘çŸ¥é“æˆ‘ä»¬éƒ½æ²¡æœ‰é”™åªæ˜¯æ”¾æ‰‹ä¼šæ¯”è¾ƒå¥½è¿‡æœ€ç¾Žçš„çˆ±æƒ…å›žå¿†é‡Œå¾…ç»­â”€â”€å‘¨æ°ä¼¦ é€€åŽ]]></content>
      <categories>
        <category>å¬æ­Œ</category>
      </categories>
      <tags>
        <tag>å¬æ­Œ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è®°äº‹æœ¬]]></title>
    <url>%2F2018%2F10%2F01%2F%E8%AE%B0%E4%BA%8B%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[æˆ‘çœ‹è§è‡ªå·±å†™ä¸‹çš„å¿ƒæƒ… æŠŠè‡ªå·±æ”¾åœ¨å‘å¾®çš„åŽå¤´ â”€â”€å‘¨ä¼ é›„ è®°äº‹æœ¬ ç¿»å¼€éšèº«æºå¸¦çš„è®°äº‹æœ¬å†™ç€è®¸å¤šäº‹éƒ½æ˜¯å…³äºŽä½ ä½ è®¨åŽŒè¢«å†·è½ä¹ æƒ¯è¢«å®ˆå€™å¯‚å¯žæ‰æ‰¾æˆ‘æˆ‘çœ‹è§è‡ªå·±å†™ä¸‹çš„å¿ƒæƒ…æŠŠè‡ªå·±æ”¾åœ¨å‘å¾®çš„åŽå¤´ç­‰ä½ ç­‰å¤ªä¹…æƒ³ä½ æ³ªä¼šæµè€Œå¹¸ç¦å¿«ä¹æ˜¯ä»€ä¹ˆçˆ±çš„ç—›äº†ç—›çš„å“­äº†å“­çš„ç´¯äº†æ—¥è®°æœ¬é‡Œé¡µé¡µæ‰§ç€è®°è½½ç€ä½ çš„å¥½åƒä¸Šç˜¾çš„æ¯’è¯å®ƒåè¦†éª—ç€æˆ‘çˆ±çš„ç—›äº†ç—›çš„å“­äº†å“­çš„ç´¯äº†çŸ›ç›¾å¿ƒé‡Œæ€»æ˜¯å¼ºæ±‚åŠè‡ªå·±è¦æ”¾æ‰‹é—­ä¸Šçœ¼è®©ä½ èµ°çƒ§æŽ‰æ—¥è®°é‡æ–°æ¥è¿‡æˆ‘çœ‹è§è‡ªå·±å†™ä¸‹çš„å¿ƒæƒ…æŠŠè‡ªå·±æ”¾åœ¨å‘å¾®çš„åŽå¤´ç­‰ä½ ç­‰å¤ªä¹…æƒ³ä½ æ³ªä¼šæµè€Œå¹¸ç¦å¿«ä¹æ˜¯ä»€ä¹ˆçˆ±çš„ç—›äº†ç—›çš„å“­äº†å“­çš„ç´¯äº†æ—¥è®°æœ¬é‡Œé¡µé¡µæ‰§ç€è®°è½½ç€ä½ çš„å¥½åƒä¸Šç˜¾çš„æ¯’è¯å®ƒåå¤éª—ç€æˆ‘çˆ±çš„ç—›äº†ç—›çš„å“­äº†å“­çš„ç´¯äº†çŸ›ç›¾å¿ƒé‡Œæ€»æ˜¯å¼ºæ±‚åŠè‡ªå·±è¦æ”¾æ‰‹é—­ä¸Šçœ¼è®©ä½ èµ°çƒ§æŽ‰æ—¥è®°é‡æ–°æ¥è¿‡çˆ±çš„ç—›äº†ç—›çš„å“­äº†å“­çš„ç´¯äº†çŸ›ç›¾å¿ƒé‡Œæ€»æ˜¯å¼ºæ±‚åŠè‡ªå·±è¦æ”¾æ‰‹é—­ä¸Šçœ¼è®©ä½ èµ°çƒ§æŽ‰æ—¥è®°é‡æ–°æ¥è¿‡â”€â”€å‘¨ä¼ é›„ è®°äº‹æœ¬]]></content>
      <categories>
        <category>å¬æ­Œ</category>
      </categories>
      <tags>
        <tag>å¬æ­Œ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¼€ä¸äº†å£]]></title>
    <url>%2F2018%2F09%2F30%2F%E5%BC%80%E4%B8%8D%E4%BA%86%E5%8F%A3%202%2F</url>
    <content type="text"><![CDATA[æ‰ç¦»å¼€æ²¡å¤šä¹…å°±å¼€å§‹ æ‹…å¿ƒä»Šå¤©çš„ä½ è¿‡å¾—å¥½ä¸å¥½ â”€â”€å‘¨æ°ä¼¦ å¼€ä¸äº†å£ æ‰ç¦»å¼€æ²¡å¤šä¹…å°±å¼€å§‹æ‹…å¿ƒä»Šå¤©çš„ä½ è¿‡å¾—å¥½ä¸å¥½æ•´ä¸ªç”»é¢æ˜¯ä½  æƒ³ä½ æƒ³çš„ç¡ä¸ç€å˜´å˜Ÿå˜Ÿé‚£å¯çˆ±çš„æ¨¡æ ·è¿˜æœ‰åœ¨ä½ èº«ä¸Šé¦™é¦™çš„å‘³é“æˆ‘çš„å¿«ä¹æ˜¯ä½  æƒ³ä½ æƒ³çš„éƒ½ä¼šç¬‘æ²¡æœ‰ä½ åœ¨æˆ‘æœ‰å¤šéš¾ç†¬ï¼ˆæ²¡æœ‰ä½ åœ¨æˆ‘æœ‰å¤šéš¾ç†¬å¤šçƒ¦æ¼ï¼‰æ²¡æœ‰ä½ çƒ¦æˆ‘æœ‰å¤šçƒ¦æ¼ï¼ˆæ²¡æœ‰ä½ çƒ¦æˆ‘æœ‰å¤šçƒ¦æ¼å¤šéš¾ç†¬ï¼‰ç©¿è¿‡äº‘å±‚ æˆ‘è¯•ç€åŠªåŠ›å‘ä½ å¥”è·‘çˆ±æ‰é€åˆ° ä½ å´å·²åœ¨åˆ«äººæ€€æŠ±å°±æ˜¯å¼€ä¸äº†å£ è®©å¥¹çŸ¥é“æˆ‘ä¸€å®šä¼šå‘µæŠ¤ç€ä½  ä¹Ÿé€—ä½ ç¬‘ä½ å¯¹æˆ‘æœ‰å¤šé‡è¦æˆ‘åŽæ‚”æ²¡ è®©ä½ çŸ¥é“å®‰é™çš„å¬ä½ æ’’å¨‡çœ‹ä½ ç¡ç€ ä¸€ç›´åˆ°è€å°±æ˜¯å¼€ä¸äº†å£ è®©å¥¹çŸ¥é“å°±æ˜¯é‚£ä¹ˆç®€å•å‡ å¥ æˆ‘åŠžä¸åˆ°æ•´é¢—å¿ƒæ‚¬åœ¨åŠç©ºæˆ‘åªèƒ½å¤Ÿ è¿œè¿œçœ‹ç€è¿™äº›æˆ‘éƒ½åšå¾—åˆ°ä½†é‚£ä¸ªäººå·²ç»ä¸æ˜¯æˆ‘æ²¡æœ‰ä½ åœ¨æˆ‘æœ‰å¤šéš¾ç†¬ï¼ˆæ²¡æœ‰ä½ åœ¨æˆ‘æœ‰å¤šéš¾ç†¬å¤šçƒ¦æ¼ï¼‰æ²¡æœ‰ä½ çƒ¦æˆ‘æœ‰å¤šçƒ¦æ¼ï¼ˆæ²¡æœ‰ä½ çƒ¦æˆ‘æœ‰å¤šçƒ¦æ¼å¤šéš¾ç†¬ï¼‰ç©¿è¿‡äº‘å±‚ æˆ‘è¯•ç€åŠªåŠ›å‘ä½ å¥”è·‘çˆ±æ‰é€åˆ° ä½ å´å·²åœ¨åˆ«äººæ€€æŠ±å°±æ˜¯å¼€ä¸äº†å£ è®©å¥¹çŸ¥é“æˆ‘ä¸€å®šä¼šå‘µæŠ¤ç€ä½  ä¹Ÿé€—ä½ ç¬‘ä½ å¯¹æˆ‘æœ‰å¤šé‡è¦æˆ‘åŽæ‚”æ²¡ è®©ä½ çŸ¥é“å®‰é™çš„å¬ä½ æ’’å¨‡çœ‹ä½ ç¡ç€ ä¸€ç›´åˆ°è€å°±æ˜¯å¼€ä¸äº†å£ è®©å¥¹çŸ¥é“å°±æ˜¯é‚£ä¹ˆç®€å•å‡ å¥ æˆ‘åŠžä¸åˆ°æ•´é¢—å¿ƒæ‚¬åœ¨åŠç©ºæˆ‘åªèƒ½å¤Ÿ è¿œè¿œçœ‹ç€è¿™äº›æˆ‘éƒ½åšå¾—åˆ°ä½†é‚£ä¸ªäººå·²ç»ä¸æ˜¯æˆ‘â”€â”€å‘¨æ°ä¼¦ å¼€ä¸äº†å£]]></content>
      <categories>
        <category>å¬æ­Œ</category>
      </categories>
      <tags>
        <tag>å¬æ­Œ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä»Šå¹´è§„åˆ’]]></title>
    <url>%2F2018%2F05%2F16%2F%E4%BB%8A%E5%B9%B4%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[ä»Šå¹´è§„åˆ’ å¹´åº•å›žæ­¦æ±‰ å­¦å¥½è‹±è¯­ å…»ä¸€åªç‹— ç…§é¡¾å¥½è‡ªå·± å¯¹çˆ¶æ¯å¥½ çæƒœæœ‹å‹]]></content>
      <categories>
        <category>åˆ†æ‰‹</category>
      </categories>
      <tags>
        <tag>è®¡åˆ’</tag>
      </tags>
  </entry>
</search>
