<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[想跑步了]]></title>
    <url>%2F2020%2F05%2F13%2F%E6%83%B3%E8%B7%91%E6%AD%A5%E4%BA%86%2F</url>
    <content type="text"><![CDATA[出生第9179天。（惊了，居然都9k多天了） 教练，我想跑步了。 看了看app上的记录，上一次跑步还是在18年6月份了。 那时候日子还挺好。有朋友，有喜欢的女生。公司离家不远，工作也不繁忙。平常找喜欢的女生聊聊天，周末偶尔和朋友出去吃顿大餐。这样的日子原来已经过去快两年了啊，时间还是那么无情呢，匆匆的来又匆匆的走，毫不停留。 怀念两年前的时光，或者说怀念两年前的自己。那时的我还是个对爱情充满了憧憬，对工作充满了热情的少年呀。时光荏苒，此去经年。现在已经从那个充满活力的少年，已经变成心如死水，波澜不惊的青年了，朝着那个饱经沧桑的油腻中年奔去了呢。 曾今的我，是那样的渴望爱情。也那么努力那么笨拙的爱过，付出过。虽然结果不太好，没有没有结果。也是那时候明白了，在爱情里并不是每一分付出都会有回报。要是能早一点明白，当时应该不会那么痛苦吧。其实人生又何尝不是这样呢，“一分耕耘一分收获”不过是童话里的故事，都是骗人的。付出过，努力过，没有回报才是常态吧。应该要学会早点接受这样的事实。而不是在付出过发现没有回报时，气急败坏，那种样子真的很丑陋呢。 不想再看到那样丑陋的自己，也不像自己再那样的卑微了。有些人有些事，没有就没有吧，得不到就得不到吧。或许有人会觉得这样的生活态度过于消极，是呢。我也曾喜欢过热血动漫里的主角，又或是个性鲜明的配角。他们永远是那么的热血，积极阳光，又充满了活力，不管遇到了多少困难或者挫折，不管被反派打倒过多少次总能一次次的爬起来继续战斗，最后上演一场正义必胜的戏码。然而现在长大了，第一个要接受的现实就是自己不是主角，而是一个再普通不过的普通人。好吧，我是自己生活的主角，但并不是小说里的主角。 以前有个女生说我不成熟，很多时候很幼稚，那时候我不懂什么是成熟。几年后再见，发现她变了，又或者当初我就不够了解她吧。她在工作之余，还做起了微商，好好的人怎么就做起微商了呢。卖的是阿胶，当然我更愿意叫它的另一个名字驴皮。然后我回过头来想她这些年的经历，专科毕业之后专升本，毕业之后靠家里的关系去了一家大公司。之后倒是靠自己混的风生水起，想挖她的猎头，和她新买的汽车都证明着这一点。后来她有过一些交集，才发现她是一个很有野心或者说上进心，明确知道自己想要什么的人。甚至愿意付出一些代价去获得也在所不惜。心里不禁感叹一声，这就是成熟吗。她在家人面前还是一副乖乖女的形象，只有我知道她的另一面。也能猜到她为现在这一切付出了多少。 说实话我承认我不够成熟。比如两年前的我，还对于爱情有着不切实际的憧憬，对于工作还有着不为五斗米而折腰的骨气。现在这些东西，都如那些被吐出的烟圈一样，随风飘散了。不再相信真爱，也不会干的不爽就想着离职了。 说到烟，22岁那年，我抽了我人生的第一包烟。有点呛，味还大，特别是拿烟的手上。抽烟的时候觉得自己终于长大了，变成大人了。有时候也会想要不要给自己来个成年礼，不想到30了还是个处男。以前对于大保健是非常抵触的，既讨厌做小姐的女生，又讨厌有女朋友或者老婆还去大保健的男生。以至于有几次朋友说请我去大保健，我都拒绝了。但是现在思想慢慢的变了，虽然我不想承认，但我确实没有以前那样抗拒了。以前给自己定的条条框框，让我活的很累。如果有效果也就罢了，关键现在也还是个臭单身狗。 记得好小的时候我就跟自己做了约定，以后不抽烟不喝酒，不聊骚不大保健。争取当好男人，这样才配上我以后喜欢的那个她。这么多年过去了，我确实很好的践行了和自己的约定。然后我发现我错了，女生并不会因为我不抽烟不喝酒不聊骚不大保健就喜欢我。她们只是嘴巴上这么说而已，想找一个好男人，好男人怎么这么少之类的。身体还有心理还是很老实的，喜欢找那些帅帅的坏坏的男生，虽然明知道他们身上有种种缺点，但总能说服自己。 所以我时常在想，这么多年我都错了吗，我还应该继续坚持自己的原则吗？我是不是应该放弃这些束缚自己的条条框框了，人生匆匆数十载，已经单身25年了还不能清醒的认识到自己错了吗，是不是应该及时行乐才是对的。身边的朋友去大保健的越来越多，哪怕是以前和我一样没去过的，后来也都堕落了。我能确定从来没去过的朋友，连我在内估计3个人左右。一个大学室友我叫他“死胖子”，属于传统好男人那种，烧得一手好菜，和我一样从来没谈过恋爱。照理说是女生嘴巴上最想要的那种绝种好男人了，然而就像我前面说的，女生不会找这种人当男朋友，他不够帅也不够坏。最多只会对他说“你是个好人”，“你老婆以后会很幸福”之类的话。还一个也类似，只不过没那么胖，感觉他还是有机会的，时间关系就不细说了。 有时想想觉得也挺没意思的。一方面好男人确实越来越少了，就像我上面说的，我身边的男生我能100%确定没去过大保健的也就2个而已。其余的，除非他们以后主动坦白，又或者不小心被发现，否则她们的另一半可能永远不会知道。而女人们，一边感叹着好男人越来越少，一边又投入坏男人的怀抱。不得不说这种情况在我看来真的很没有意思呢。 就先写到这吧，写着写着就跑题了呢，跟跑步完全没什么关系了。洋洋洒洒写了2k字，很难想象高中的我是个800都得抓破脑袋的少年，哈哈，这两年的博客生涯对于我水字数的水平还是提升很大的。]]></content>
      <tags>
        <tag>跑步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今日事]]></title>
    <url>%2F2020%2F05%2F12%2F%E4%BB%8A%E6%97%A5%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[想了想把删掉的又放回了，反正也没有看，就自己一个。 然后今天不在状态，带了电脑，没带电脑的充电器，人都傻了。现在还有67%的🔋，有点焦虑。 update 我傻了，我发现我打字时候偶尔会出现漏字的情况，脑袋里读出来了，然后打出来的时候却省略了。黑人？.jpg 比如“又放回来了”这句，脑袋里是这么想的，结果打出来“来”字没有了。奇怪的是“人”字掉了两遍。难道是我有什么心理或者精神方面的疾病？]]></content>
  </entry>
  <entry>
    <title><![CDATA[感觉并没有npy]]></title>
    <url>%2F2020%2F05%2F12%2F%E6%84%9F%E8%A7%89%E5%B9%B6%E6%B2%A1%E6%9C%89npy%2F</url>
    <content type="text"><![CDATA[只是闺蜜罢了，不管是微博还是朋友圈又或者是刚认识那会的态度，都不像有男朋友的样子。只不过现在这些都不重要，她告诉我有男朋友本身就是一种态度了。果然追女生也要有技巧，我太菜了。 今天没带电脑充电线，我傻了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[有男朋友了]]></title>
    <url>%2F2020%2F05%2F11%2F%E6%9C%89%E7%94%B7%E6%9C%8B%E5%8F%8B%E4%BA%86%2F</url>
    <content type="text"><![CDATA[这么好看的女生有男朋友也不奇怪，只是看微博和朋友圈还以为去年分了，现在是单身呢，可能先入为主吧。 过几天删了好了，好好背单词吧，最近在地铁上都在划水，没有认真背单词。 还想着斐斐手机电池不经用，到时候送她一个新的，也不必等什么节日，早一天送可以早一天用上。何况，有女朋友的日子每天都是情人节。]]></content>
  </entry>
  <entry>
    <title><![CDATA[2020年-第20周周计划]]></title>
    <url>%2F2020%2F05%2F10%2F2020%E5%B9%B4-%E7%AC%AC20%E5%91%A8%E5%91%A8%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[新的一周，希望有新的心情吧，不要再沉浸在郁闷和悲伤里了，还有那么多单词等着呢。 本周计划： 继续背单词。上班还是途经三坝吧，下班就走新路线省点时间。 周一打卡 Studied ⁨201⁩ cards ⁨in ⁨30.18⁩ minutes⁩ today (⁨9.01⁩s/card)Again count: 74 (63.18% correct)Learn: 139, Review: 40, Relearn: 22, Filtered: 0No mature cards were studied today. 越来越短了（大雾 周二打卡 Studied ⁨248⁩ cards ⁨in ⁨40.97⁩ minutes⁩ today (⁨9.91⁩s/card)Again count: 124 (50.00% correct)Learn: 179, Review: 37, Relearn: 32, Filtered: 0No mature cards were studied today. 习惯孤独。 本周随记： 没事，习惯就好。]]></content>
      <tags>
        <tag>周计划</tag>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好像没机会了呢]]></title>
    <url>%2F2020%2F05%2F10%2F%E5%A5%BD%E5%83%8F%E6%B2%A1%E6%9C%BA%E4%BC%9A%E4%BA%86%E5%91%A2%2F</url>
    <content type="text"><![CDATA[和斐斐认识的第11天 好像已经GG了。 一点都不感到意外呢，啊，果然还是太不会追女生了，所以单身这么多年。 算了，感情这种事情勉强不得，人家对我没兴趣也没办法。 收拾心情，好好工作学习吧。 平常就不打扰别人了吧，如果地铁遇到，简单打个招呼就好了，不要惹人讨厌。 要坚强起来呀，毕竟也不是第一次了，想起了动画里反派，每次被打飞之后都会说一句”好讨厌的感觉啊“。哈哈，唉。 本来还想以后确定关系了，再把这个博客给斐斐看，会很有意义吧。果然“是我想太多你总这样说”。翻翻第一天写的博客，说的没错，想的太多，想的太美。 最后还是只感动了自己呀。 End。]]></content>
      <tags>
        <tag>难过</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搞不懂]]></title>
    <url>%2F2020%2F05%2F10%2F%E6%90%9E%E4%B8%8D%E6%87%82%2F</url>
    <content type="text"><![CDATA[和斐斐认识的第11天 不是很明白斐斐对我的态度。 就很困惑，说不感兴趣吧，也没顺着台阶让我以后不要找她了。说感兴趣吧，一搞一天不回消息。 啊，要死了。 忍住不要找斐斐。 还是找了，没出息。 以后不要找了。 立flag时间 5/10 6:30。]]></content>
      <tags>
        <tag>困惑</tag>
        <tag>迷茫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[感觉今天在躲着我]]></title>
    <url>%2F2020%2F05%2F09%2F%E6%84%9F%E8%A7%89%E4%BB%8A%E5%A4%A9%E5%9C%A8%E8%BA%B2%E7%9D%80%E6%88%91%2F</url>
    <content type="text"><![CDATA[和斐斐认识的第10天 是在躲着我嘛 不是！ 耶啊哈 又不理我了。 唉。]]></content>
      <tags>
        <tag>难过</tag>
        <tag>😫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[见面]]></title>
    <url>%2F2020%2F05%2F08%2F%E8%A7%81%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[和斐斐认识的第9天。 今天斐斐终于见到我了，emmm，听起来怪怪的，哈哈哈。 不知道有没有吓到她，希望不要讨厌我。 还想着找机会约斐斐出去呢，感情啊感情快点升温吧。 话说今天在三坝前一站遇到了呢，比在三坝遇到更巧。 啊，感情好像变淡了，是我太敏感了吗，还是是真的呢。好难受哦。患得患失。 原来在洗澡，虚惊一场。]]></content>
      <tags>
        <tag>紧张</tag>
        <tag>见面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[听我唱童话的斐斐]]></title>
    <url>%2F2020%2F05%2F07%2F%E5%90%AC%E6%88%91%E5%94%B1%E7%AB%A5%E8%AF%9D%E7%9A%84%E6%96%90%E6%96%90%2F</url>
    <content type="text"><![CDATA[和斐斐认识的第8天 昨天晚上给斐斐唱了一段童话，唱完之后感觉特别羞耻。以至于开了消息免打扰，都不敢接收消息。 还好斐斐第二天告诉我唱的还可以，暗暗开心。 然后今天又拖延了，没能见到斐斐。 明天得起早点了。]]></content>
      <tags>
        <tag>开心</tag>
        <tag>😁️</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[👴又快乐咯]]></title>
    <url>%2F2020%2F05%2F06%2F%F0%9F%91%B4%E5%8F%88%E5%BF%AB%E4%B9%90%E5%92%AF%2F</url>
    <content type="text"><![CDATA[和斐斐认识的第7天 斐斐又理我了！ 爷又快乐咯.jpg 为什么聊天能这么开心呢。 嘻嘻嘻 嘿嘿 udpate 19:46 今天又是开心的一天 希望明天能遇到斐斐]]></content>
      <tags>
        <tag>开心</tag>
        <tag>😄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自我感觉良好？]]></title>
    <url>%2F2020%2F05%2F05%2F%E8%87%AA%E6%88%91%E6%84%9F%E8%A7%89%E8%89%AF%E5%A5%BD%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[其实仔细想想，觉得聊天开心好像只是我单方面的错觉而已呢。 一呢，这几天她从来没有主动找过我，二呢，每次她都会结束话题。比如要睡觉了，要收拾行李了，要去赶车了。 结合这两点，她对我应该不感兴趣。现实总是残忍的，残忍到让人不想面对，不愿相信。 但现实就是现实。 减少对她的“骚扰”吧，不给对方造成困扰是我的底线。]]></content>
      <tags>
        <tag>难过</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找到了斐斐的网易云]]></title>
    <url>%2F2020%2F05%2F05%2F%E6%89%BE%E5%88%B0%E4%BA%86%E6%96%90%E6%96%90%E7%9A%84%E7%BD%91%E6%98%93%E4%BA%91%2F</url>
    <content type="text"><![CDATA[今天突然想到，斐斐分享给我的歌曲链接里面会不会有userid之类的信息。抱着试一试的心态一看还真有，接下来就简单了。 顺利的找到，但是没点关注，免得吓到人家。 做个记录]]></content>
  </entry>
  <entry>
    <title><![CDATA[不想找了，生气]]></title>
    <url>%2F2020%2F05%2F05%2F%E4%B8%8D%E6%83%B3%E6%89%BE%E4%BA%86%EF%BC%8C%E7%94%9F%E6%B0%94%2F</url>
    <content type="text"><![CDATA[和斐斐认识的第6天 生气😠 从昨天早上到现在都没回消息，哼。]]></content>
  </entry>
  <entry>
    <title><![CDATA[2020年-第19周周计划]]></title>
    <url>%2F2020%2F05%2F04%2F2020%E5%B9%B4-%E7%AC%AC19%E5%91%A8%E5%91%A8%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[学习 本周计划： 继续背单词，单词太多上下班时间搞不定，加上中午的时间好了。 周一打卡 Studied 238 cards in 34.40 minutes (8.67s/card)Again count: 88 (63.03% correct)Learn: 162, Review: 42, Relearn: 34, Filtered: 0No mature cards were studied today. 不以时间论英雄 周二打卡 Studied 149 cards in 34.48 minutes (13.89s/card)Again count: 41 (72.48% correct)Learn: 112, Review: 24, Relearn: 13, Filtered: 0No mature cards were studied today. 周三打卡 Studied 633 cards in 1.31 hours (7.43s/card)Again count: 309 (51.18% correct)Learn: 389, Review: 121, Relearn: 123, Filtered: 0No mature cards were studied today. 周四打卡 Studied 470 cards in 1.10 hours (8.40s/card) Again count: 211 (55.11% correct) Learn: 309, Review: 74, Relearn: 87, Filtered: 0 No mature cards were studied today. 周5打卡 Studied 315 cards in 41.30 minutes (7.87s/card) Again count: 147 (53.33% correct)Learn: 246, Review: 47, Relearn: 22, Filtered: 0 No mature cards were studied today. 周六 忘记打卡了 周日打卡 Studied ⁨131⁩ cards ⁨in ⁨30.77⁩ minutes⁩ today (⁨14.09⁩s/card)Again count: 56 (57.25% correct)Learn: 84, Review: 7, Relearn: 40, Filtered: 0No mature cards were studied today. 刷题刷题❌ 看书看书❌ 减少玩电脑的时间 ✅ 本周随记：]]></content>
      <tags>
        <tag>周计划</tag>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[早睡是真的]]></title>
    <url>%2F2020%2F05%2F04%2F%E6%97%A9%E7%9D%A1%E6%98%AF%E7%9C%9F%E7%9A%84%2F</url>
    <content type="text"><![CDATA[认识斐斐的第5天 昨天说的早睡是真的哦 太好了，不是讨厌我。 开心 啊，要死了。 半天没理我。]]></content>
  </entry>
  <entry>
    <title><![CDATA[今天也想找你]]></title>
    <url>%2F2020%2F05%2F03%2F%E4%BB%8A%E5%A4%A9%E4%B9%9F%E6%83%B3%E6%89%BE%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[和斐斐认识的第4天。 难以言喻的心情 告诉自己平常心，平常心 可是还是好想找你，可是找你说什么呢，想说的有很多，聊聊工作？聊聊摄影？然后再发散一下。还可以聊聊歌，聊聊综艺。可以是要怎么开口呢。 还是说等到节后，在聊聊假期怎么过的？ 啊啊啊啊啊啊 更新时间：2020-05-03 21:40:32 今天聊了好多 开心死了。 哈哈哈，今天会做个美梦吧。 说到做梦，斐斐说困了然后结束了聊天，真的困了嘛还是不想和我聊天所以这样说的呢。 苦恼，喜忧参半的感觉，痛并快乐着。 还是很开心就是了，嘻嘻，嘴角疯狂上扬。 快乐就是这么简单，啊，要是能做我女朋友，那会有多开心哦，不能想象。 对了斐斐原来是UI，然后比我大一岁。太好了，UI感觉很配诶，年龄倒没什么，虽然比我大，但我要照顾好她。]]></content>
      <tags>
        <tag>斐斐</tag>
        <tag>日记</tag>
        <tag>开心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[想和你聊天呢]]></title>
    <url>%2F2020%2F05%2F02%2F%E6%83%B3%E5%92%8C%E4%BD%A0%E8%81%8A%E5%A4%A9%E5%91%A2%2F</url>
    <content type="text"><![CDATA[和斐斐认识的第3天。 想和你聊天呢。 但是又不敢，小心翼翼的我。 怕找你太频繁会被你烦，或者有戒心？]]></content>
      <tags>
        <tag>斐斐</tag>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[恋爱大事记]]></title>
    <url>%2F2020%2F05%2F01%2F%E6%81%8B%E7%88%B1%E5%A4%A7%E4%BA%8B%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[和斐斐认识的第2天 想弄一个时间轴，记录和斐斐的重要时刻。 2020年04月29日三坝地铁初相遇，一见斐斐误终身。究竟是什么吸引了我呢，是那双弯弯的娥眉，还是那对清澈的眼眸，或许都是吧。就这样，我心不在焉的扒拉着手机，屏幕上的单词卡一个个的划过，而我的心思却早已不在这了。而是随着我的目光到了那姑娘的脸上，看着那细细长长的眉毛，我不禁在心里暗赞一声“好美”。想着要不要搭讪呢，但是车上人多，怕出声搭讪她会尴尬，又怕被拒绝后自己会尴尬。就在这样纠结中，地铁来到了凤起路。她要下车了，临走前看了我一眼，我没有读懂那个眼神，是鼓励还是白眼？我不知道，而她已经走远。地铁继续前进，我的魂却似乎丢了。仿佛行尸走肉一般沿着熟悉的路线走向公司，无论是屏幕上的代码，还是中午食堂的饭菜，都没能让我恢复往日的状态。就这样在懊恼和后悔中，终于引来了下班。想着在三坝守株待兔还能不能再次遇见她呢，于是乎我从6点等到了8点。或许是我人太多我看丢了，又或许是她还没下班，总之她没有再出现。是呢，生活不是电视剧，没有那么多的巧合，哪有那么巧能再次遇见呢。长长的吐出一口气，掂了掂身上的背包，走了。那一天的单词也没有背，临睡前调整了闹钟，提前了20分钟，想着明天再去等等看，怀着这样的想法睡了。 2020年04月30日闹钟比平时早了20分钟响起，而我也马不停蹄赶往三坝，不敢耽误丝毫更没有往日的赖床和磨蹭。站在初次见面的地方，我开始静候。不断的用目光扫描着每一位行人，试图能够找到她。很怕她换了衣服我没认出。时间一点点流逝，正如我的心一点点下沉。时间临近我给自己定的deadline，我决定再等最后两班地铁，如果没遇见就五一后再做打算。就在这时，出现了一道身影，白色的上衣，过肩的长发，发梢带有一些栗色。好像是她，但我有不敢确定，只能赌一赌，就这样跟在她身后进了车厢。一如昨天静静地看着她，也如昨天被她白了一眼，这眼神让我有些熟悉。决定搭讪试一试，但是一直没有找到好的时机，偏偏又上来一个人挡在我前面。心中焦急万分，想着要不要下车了再叫住她搭讪还是用手机写好搭讪的话给她看。就在我思绪万千时，看到她打开了一个链接，填写了一些个人信息，其中就有手机号码，我忍不住头脑发热，心跳加速，心中默念着那11个数字，一边掏出手机飞快解锁，记了下来。稍稍松了口气，又去确认了一遍。确认没错后，用这个号码搜了一下微信。汤圆子，没错就是她。昨天看到的微信名字就是这个。到了这个时候一颗心才彻底的放了下来。不过加她好友是下班后了，想了好久的好友消息，点击发送之后半天没有通过，更是度日如年，想着要不要再发一次好友申请，又怕不好。在这样患得患失中过了一小时，终于通过了。想了想第一句先道了个歉，毕竟不是什么正大光明的事情，然后愉快的聊了起来（个人感觉很愉快）。 2020年05月01日雨。今天只聊了一句，怕她有压力，引起反感。其实有很多话想说。我的心里也下雨了。明天会怎样呢。 2020年05月02日好想和你聊天哦 2020年05月03日今天聊了超多，就是最后斐斐说要睡觉了，让我有些担心，是不是烦我了呢。 2020年05月08日今天见面啦 2020年05月10日两天没回消息，我应该“懂事”一点不去骚扰她了。蛮可惜的，偌大的城市，能遇见着实不容易，很想珍惜这份缘分，只可惜自己魅力还是不够吧，也不能怪别人女生。 仔细想想哦，当初主管找我谈说想把我调到YJ，我要是没同意，又或者YJ没搬家，又或者在YJ我没被调到另一个组导致上班时间提前半小时，我根本不会遇到斐斐。只有上面种种全部满足了，我才能遇见她，还是两次。而且是在我怂了的情况下，她输了号码，这样我才能有机会加到她。曾经真的以为就是上天给我的缘分了，而我也选择了好好珍惜。奈何，有缘无份吧。 希望能尽早从这郁闷的心情中走出来。 👴的青春结束啦。 全剧终]]></content>
      <tags>
        <tag>恋爱时间线</tag>
        <tag>恋爱大事记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开心到飞起！]]></title>
    <url>%2F2020%2F04%2F30%2F%E5%BC%80%E5%BF%83%E5%88%B0%E9%A3%9E%E8%B5%B7%EF%BC%81%2F</url>
    <content type="text"><![CDATA[和斐斐认识的第1天 居然真的又碰到了！ 努力没有白费。 记一下自己写的备忘录 4月29日 三坝站偶遇，凤起路分别，遗憾没搭讪时间线整理，盼再次相遇。早7:22扫码骑单车骑行5分47秒早7:28分到地铁站换乘时间未知早8:23到达江锦路 行动代号：寻找汤圆儿子计划：首先7:28之前要到达地铁站，不确定拱宸桥东站能否遇到，先坐地铁到三坝，然后在楼梯口或者最右侧车厢等候，等3趟的样子等了七八趟。到站记录时间，对比8:23分调整时间轴。拜托了。好想回到过去。也没敢仔细看，不太记得样子了，不过再见一次应该能认出，只记得眉毛很细很好看。手指的皮肤不是很好。等变成女朋友给她买护手霜。想得太过了。想得太美了。 倒推钱江路-凤起路 11分27秒，停留约1分钟。干，计时器停了。三坝-拱宸桥 9分47地铁口到候车点大概2分10秒全程12分钟左右 三坝守株待兔4月29日18时07分晚高峰3分钟一趟早高峰时间待测 等到20点，不行就明天早起。19点50了，不会以后真的见不到了吧。偏偏过两天放假，最担心不是上班路线而是有什么事才做地铁的，那就碰不到。真傻逼，明明都眼神暗示两次了，后知后觉。 凭记忆写下戴眼镜，白色上衣，长发有颜色，身高168左右。 我是傻逼！ 7：06 到地铁口，可以等22分钟 等车4分钟7：25 到三坝站早高峰也是3分钟一趟可以等到7：507：32第一辆空车，还有20分钟7：39第二辆空车，感觉希望越来越渺茫了估摸着还能等10分钟应该是等不到了不确定，就这个了，观察下。 就是这个！汤圆子！终于遇到你 还好我没放弃。]]></content>
      <tags>
        <tag>开心</tag>
        <tag>邂逅</tag>
        <tag>幸运</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今天不开心]]></title>
    <url>%2F2020%2F04%2F29%2F%E4%BB%8A%E5%A4%A9%E4%B8%8D%E5%BC%80%E5%BF%83%2F</url>
    <content type="text"><![CDATA[记一下。 没有读懂那个眼神。 讨厌凤起路。我爱凤起路，我爱杭州。]]></content>
      <tags>
        <tag>怂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020年-第18周周计划]]></title>
    <url>%2F2020%2F04%2F27%2F2020%E5%B9%B4-%E7%AC%AC18%E5%91%A8%E5%91%A8%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[上周的计划执行的还不错，除了刷题和做雅思，好吧一共三个计划只执行了一个。 本周计划： 继续背单词，单词太多上下班时间搞不定，加上中午的时间好了。 周一打卡 Studied 799 cards in 2.34 hours (10.53s/card)Again count: 402 (49.69% correct)Learn: 584, Review: 133, Relearn: 82, Filtered: 0No mature cards were studied today. 周二打卡 Studied 1,147 cards in 2.75 hours (8.64s/card)Again count: 455 (60.33% correct)Learn: 784, Review: 200, Relearn: 163, Filtered: 0No mature cards were studied today. 👴累了 周三打卡 Studied 738 cards in 1.86 hours (9.07s/card)Again count: 307 (58.40% correct)Learn: 494, Review: 142, Relearn: 102, Filtered: 0No mature cards were studied today. 今天心情不好，或者说心情很差。背不下去了，今天单词记得很快，但是没心情背。 周四打卡 没心情背单词：） 周五打卡 Studied 538 cards in 1.32 hours (8.83s/card)Again count: 250 (53.53% correct)Learn: 394, Review: 95, Relearn: 49, Filtered: 0No mature cards were studied today. 心情还没恢复 周六打卡 Studied 195 cards in 1.02 hours (18.78s/card)Again count: 90 (53.85% correct)Learn: 161, Review: 12, Relearn: 22, Filtered: 0No mature cards were studied today. 直线下滑，明天要振作起来呀 周日打卡 Studied 287 cards in 27.43 minutes (5.74s/card)Again count: 138 (51.92% correct)Learn: 208, Review: 56, Relearn: 23, Filtered: 0No mature cards were studied today. 刷题刷题 看书看书 减少玩电脑的时间 本周随记： 待]]></content>
      <tags>
        <tag>周计划</tag>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[想买东西]]></title>
    <url>%2F2020%2F04%2F20%2F%E6%83%B3%E4%B9%B0%E4%B8%9C%E8%A5%BF%2F</url>
    <content type="text"><![CDATA[手表还是mbp呢。 过几天抢动森限定版。 不，你不想。 再过段时间就是六四了。 去年还发了博，今年也发个。]]></content>
  </entry>
  <entry>
    <title><![CDATA[2020年-第17周周计划]]></title>
    <url>%2F2020%2F04%2F20%2F2020%E5%B9%B4-%E7%AC%AC17%E5%91%A8%E5%91%A8%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[最近自己的节奏不对，由于工作调动和工作内容的变更已经好久没刷题了。紧迫的时间让我意识到不能再这样下去了。5年的计划属实太大，以至于让我每次想起来就头疼，开始怀疑自己能否做到。 所以我决定将计划制定得更小更细致，以周为单位，每周制定一次，从这周开始，这周是第17周。 TODO List: 下载Anki，导入单词。(下好了，导入了7000个单词，叫甚么麦克米伦7000，听起来像麦哲伦又像光轮2000) Android版的不要钱，IOS要 US$24.99，实在太贵，不行就某宝吧。（淘宝买的美区key） 本周计划： 利用上下班通勤时间用Anki背单词，这东西应该还有点学习成本，需要琢磨下。（搞定了） 周一打卡（20个） 周二打卡（今天大概背了130个，明天调整到200） 周三打卡 TodayStudied 746 cards in 2.07 hours (9.97s/card)Again count: 231 (69.03% correct)Learn: 635, Review: 89, Relearn: 22, Filtered: 0No mature cards were studied today. 今天背了好多，头都晕了，整个中学有这么努力应该能上个985。 周四打卡 TodayStudied 1,076 cards in 2.63 hours (8.81s/card)Again count: 436 (59.48% correct)Learn: 690, Review: 200, Relearn: 186, Filtered: 0No mature cards were studied today. 周5打卡，今天聚餐去了 TodayStudied 700 cards in 1.86 hours (9.55s/card)Again count: 294 (58.00% correct)Learn: 499, Review: 135, Relearn: 66, Filtered: 0No mature cards were studied today. 周六打卡（不在状态） TodayStudied 1,242 cards in 1.67 hours (4.84s/card)Again count: 562 (54.75% correct)Learn: 930, Review: 200, Relearn: 112, Filtered: 0No mature cards were studied today. 周日打卡 Today Studied 1,098 cards in 2.09 hours (6.87s/card)Again count: 458 (58.29% correct)Learn: 784, Review: 200, Relearn: 114, Filtered: 0No mature cards were studied today. 到家之后刷题。（看今天能不能做到） 周二（果然今天没有刷题，回来就堕落了，还好单词是背了，争取明天步入正轨） 周末看书，买的雅思书现在📦还没开封呢。 本周随记： 丢你雷姆，真的感觉记忆力下降了。早上一个analogous(类似的)，还有个collision(碰撞)背了七八遍。真的要努力了，再拖几年，记忆力精力下降更严重，那就只能在这里等死了。 今天大概背了20个新词，感觉慢了点。背单词这种事就应该一次性背很多，然后复习。比如同样100个单词，一天背100个然后不断复习，效果应该好过每天背10个这种。]]></content>
      <tags>
        <tag>周计划</tag>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-156 Binary Tree Upside Down]]></title>
    <url>%2F2020%2F04%2F13%2FLeetCode-156%2F</url>
    <content type="text"><![CDATA[遇到的第一个上锁的题，什么信息都没有。 有点像神奇宝贝里面的“猜猜我是谁”环节。]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-145 Binary Tree Postorder Traversal]]></title>
    <url>%2F2020%2F04%2F13%2FLeetCode-145%2F</url>
    <content type="text"><![CDATA[Level: Hard Given a binary tree, return the postorder traversal of its nodes’ values. Example: 12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [3,2,1] Follow up: Recursive solution is trivial, could you do it iteratively? 思路: 后序遍历难度居然是Hard，可能指的是题目的额外要求使用迭代实现吧。使用迭代确实很简单，先写个试试。 代码: 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); helper(root, result); return result; &#125; public void helper(TreeNode root, List&lt;Integer&gt; result)&#123; if (root == null)&#123; return; &#125; helper(root.left, result); helper(root.right, result); result.add(root.val); return; &#125;&#125; 用递归写确实很简单，中间粗心，public void helper(TreeNode root, List&lt;Integer&gt; result)写掉了List&lt;Integer&gt;直接写了result，其他都🆗。 我注意到这两题内存使用，基本都只超过了5%的人，说明迭代的方法更省内存呀，抽空得学下三种遍历迭代的写法。记得之前哪一题用到过，不过只写过一次，印象不深刻。 迭代版待续 复习: Time Submitted Status Runtime Memory Language 9 minutes ago Accepted 0 ms 38.3 MB java Last update time: 2020年4月13日 10点47分]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-144 Binary Tree Preorder Traversal]]></title>
    <url>%2F2020%2F04%2F13%2FLeetCode-144%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree, return the preorder traversal of its nodes’ values. Example: 12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [1,2,3] Follow up: Recursive solution is trivial, could you do it iteratively? 思路: 哦嚯~简单的先序遍历，纯手敲一次过。 代码: 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if (root == null)&#123; return result; &#125; helper(root, result); return result; &#125; public void helper(TreeNode root, List&lt;Integer&gt; result)&#123; if (root != null)&#123; result.add(root.val); &#125; if (root.left != null)&#123; helper(root.left, result); &#125; if (root.right != null)&#123; helper(root.right, result); &#125; return; &#125;&#125; 其实代码可以精简一下，上面是第一次的版本，下面是第二次的版本，改动不大，就是行数变少了。 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); helper(root, result); return result; &#125; public void helper(TreeNode root, List&lt;Integer&gt; result)&#123; if (root == null)&#123; return; &#125; result.add(root.val); helper(root.left, result); helper(root.right, result); return; &#125;&#125; 复习: Time Submitted Status Runtime Memory Language 7 minutes ago Accepted 0 ms 37.5 MB java 11 minutes ago Accepted 0 ms 37.7 MB java Last update time : 2020年4月13日 10点30分]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-129 Sum Root to Leaf Numbers]]></title>
    <url>%2F2020%2F04%2F12%2FLeetCode-129%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Example: 123456789Input: [1,2,3] 1 / \ 2 3Output: 25Explanation:The root-to-leaf path 1-&gt;2 represents the number 12.The root-to-leaf path 1-&gt;3 represents the number 13.Therefore, sum = 12 + 13 = 25. Example 2: 123456789101112Input: [4,9,0,5,1] 4 / \ 9 0 / \5 1Output: 1026Explanation:The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.The root-to-leaf path 4-&gt;0 represents the number 40.Therefore, sum = 495 + 491 + 40 = 1026. 思路: ​ 我的想法是利用先序遍历，先后获取到根和子节点的值。再用StringBuilder的append()方法，拼出一个String类型的数，再add进一个List&lt;String&gt;。最后遍历List，同时把String转成int相加返回。最后点击Run Code成功了，激动，接着点击Submit报错了，一点也不吃惊呢。 错误答案: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int sumNumbers(TreeNode root) &#123; List&lt;String&gt; sl = new ArrayList&lt;String&gt;(); if(root == null)&#123; return 0; &#125; int result = 0; helper(root.left, root.right, sl, root.val); for (int i = 0; i &lt; sl.size(); i++)&#123; int temp = Integer.parseInt(sl.get(i)); result += temp; &#125; return result; &#125; public int helper(TreeNode left, TreeNode right, List&lt;String&gt; sl, int rootVal)&#123; if (left != null)&#123; StringBuilder sb = new StringBuilder(); sb.append(rootVal); sb.append(left.val); sl.add(sb.toString()); &#125; if (right != null)&#123; StringBuilder sb = new StringBuilder(); sb.append(rootVal); sb.append(right.val); sl.add(sb.toString()); &#125; // sl.add(sb.toString()); if (left.left != null &amp;&amp; right.right != null)&#123; return helper(left.left, right.right, sl, rootVal); &#125; return 0; &#125;&#125; 正确代码: 123456789public int sumNumbers(TreeNode root) &#123; return sum(root, 0);&#125;public int sum(TreeNode n, int s)&#123; if (n == null) return 0; if (n.right == null &amp;&amp; n.left == null) return s*10 + n.val; return sum(n.left, s*10 + n.val) + sum(n.right, s*10 + n.val);&#125; 果然算法的正确答案一般都不会太长，Hard难度另说，之前碰到的Morris Traversal就挺长的。 说实话不太会个十百位数的转换，所以第一想法是先拼成String再转int，虽然明知这样效率不高，还有可能报转换异常。 今天先到这吧。 复习: 留个坑 Time Submitted Status Runtime Memory Language 14 minutes ago Wrong Answer N/A N/A java 14 minutes ago Wrong Answer N/A N/A java]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-99 Recover Binary Search Tree]]></title>
    <url>%2F2020%2F04%2F12%2FLeetCode-99%2F</url>
    <content type="text"><![CDATA[Level: Hard Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: 123456789101112131415Input: [1,3,null,null,2] 1 / 3 \ 2Output: [3,1,null,null,2] 3 / 1 \ 2 Example 2: 123456789101112131415Input: [3,1,4,null,null,2] 3 / \1 4 / 2Output: [2,1,4,null,null,3] 2 / \1 4 / 3 Follow up: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? 原来这个才是我遇到的第一个难度为Hard的题 中序遍历不符合题目常数空间的要求，然后就有了莫里斯遍历 Morris Traversal 12345678910111213141516171819202122232425262728293031323334353637383940414243public void recoverTree(TreeNode root) &#123; TreeNode pre = null; TreeNode first = null, second = null; // Morris Traversal TreeNode temp = null; while(root!=null)&#123; if(root.left!=null)&#123; // connect threading for root temp = root.left; while(temp.right!=null &amp;&amp; temp.right != root) temp = temp.right; // the threading already exists if(temp.right!=null)&#123; if(pre!=null &amp;&amp; pre.val &gt; root.val)&#123; if(first==null)&#123;first = pre;second = root;&#125; else&#123;second = root;&#125; &#125; pre = root; temp.right = null; root = root.right; &#125;else&#123; // construct the threading temp.right = root; root = root.left; &#125; &#125;else&#123; if(pre!=null &amp;&amp; pre.val &gt; root.val)&#123; if(first==null)&#123;first = pre;second = root;&#125; else&#123;second = root;&#125; &#125; pre = root; root = root.right; &#125; &#125; // swap two node values; if(first!= null &amp;&amp; second != null)&#123; int t = first.val; first.val = second.val; second.val = t; &#125; &#125;//https://leetcode.com/problems/recover-binary-search-tree/discuss/32559/Detail-Explain-about-How-Morris-Traversal-Finds-two-Incorrect-Pointer 看不懂，今天还一题都没有做。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-98 Validate Binary Search Tree]]></title>
    <url>%2F2020%2F04%2F12%2FLeetCode-98%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example 1: 123456 2 / \ 1 3Input: [2,1,3]Output: true Example 2: 123456789 5 / \ 1 4 / \ 3 6Input: [5,1,4,null,null,3,6]Output: falseExplanation: The root node&apos;s value is 5 but its right child&apos;s value is 4. 方法一: 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isValidBST(TreeNode root) &#123; if (root == null) return true; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode pre = null; while (root != null || !stack.isEmpty()) &#123; // while (root != null) &#123; stack.push(root); root = root.left; &#125; root = stack.pop(); if(pre != null &amp;&amp; root.val &lt;= pre.val) return false; pre = root; root = root.right; &#125; return true; &#125;&#125; 方法二： 1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isValidBST(TreeNode root) &#123; return helper(root,Integer.MIN_VALUE,Integer.MAX_VALUE); &#125; public boolean helper(TreeNode root,Integer min, Integer max)&#123; if (root == null)&#123; return true; &#125; if (root.val &gt;= max || root.val &lt;= min) return false; return helper(root.left, min, root.val)&amp;&amp;helper(root.right,root.val,max); &#125; &#125; Test case: [2147483647]会报错，正好是 Integer.MAX_VALUE的临界值。 方法二改(自己): 1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isValidBST(TreeNode root) &#123; return helper(root,Long.MIN_VALUE,Long.MAX_VALUE); &#125; public boolean helper(TreeNode root,Long min, Long max)&#123; if (root == null)&#123; return true; &#125; if (root.val &gt;= max || root.val &lt;= min) return false; return helper(root.left, Long.valueOf(min), Long.valueOf(root.val)) &amp;&amp; helper(root.right,Long.valueOf(root.val),Long.valueOf(max)); &#125; &#125; 想法也很简单，把Integer换成Long，这样遇到这个test case就不会报错了。 方法二改(评论区): 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isValidBST(TreeNode root) &#123; return helper(root, null, null); &#125; boolean helper(TreeNode root, Integer min, Integer max) &#123; if (root == null) return true; if ((min != null &amp;&amp; root.val &lt;= min) || (max != null &amp;&amp; root.val &gt;= max)) return false; return helper(root.left, min, root.val) &amp;&amp; helper(root.right, root.val, max); &#125;&#125;// 链接：https://leetcode.com/problems/validate-binary-search-tree/discuss/32138/Another-passed-Java-solution 这种更优雅，用我那种方法，test case换个Long的临界值，估计又会报错了。只是算暂时解决了问题，并没有完全解决问题。 复习记录: Time Submitted Status Runtime Memory Language 9 minutes ago Accepted 0 ms 39.3 MB java 13 minutes ago Accepted 0 ms 39.1 MB java 21 minutes ago Wrong Answer N/A N/A java 9 days ago Accepted 1 ms 39.5 MB java Last Update Time : 2020年4月10日 10点52分]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-96 Unique Binary Search Trees]]></title>
    <url>%2F2020%2F04%2F12%2FLeetCode-96%2F</url>
    <content type="text"><![CDATA[Level: Medium Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n? Example: 12345678910Input: 3Output: 5Explanation:Given n = 3, there are a total of 5 unique BST&apos;s: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 暂空]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-95 Unique Binary Search Trees II]]></title>
    <url>%2F2020%2F04%2F12%2FLeetCode-95%2F</url>
    <content type="text"><![CDATA[Level: Medium Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n. Example: 1234567891011121314151617Input: 3Output:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]Explanation:The above output corresponds to the 5 unique BST&apos;s shown below: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 暂空]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-94 Binary Tree Inorder Traversal]]></title>
    <url>%2F2020%2F04%2F12%2FLeetCode-94%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree, return the inorder traversal of its nodes’ values. Example: 12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively? 思路: ​ 一个简单的中序遍历 代码: 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if (root == null)&#123; return result; &#125; helper(root, result); return result; &#125; public List&lt;Integer&gt; helper(TreeNode root, List&lt;Integer&gt; result)&#123; if (root.left != null)&#123; helper(root.left, result); &#125; result.add(root.val); if (root.right != null)&#123; helper(root.right, result); &#125; return result; &#125;&#125; 复习(提交记录): Time Submitted Status Runtime Memory Language 7 minutes ago Accepted 0 ms 37.8 MB java 7 days ago Accepted 0 ms 37.3 MB java 9 days ago Accepted 0 ms 37.8 MB java Last update time : 2020年4月9日 17点24分]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-124 Binary Tree Maximum Path Sum]]></title>
    <url>%2F2020%2F04%2F09%2FLeetCode-124%2F</url>
    <content type="text"><![CDATA[Level: Hard Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1: 1234567Input: [1,2,3] 1 / \ 2 3Output: 6 Example 2: 123456789Input: [-10,9,20,null,null,15,7] -10 / \ 9 20 / \ 15 7Output: 42 遇到的第一个难度为Hard的题，这个单词直接让我放弃了思考，直奔评论区。 真是他妈的优雅呀 1234567891011121314151617181920212223public class Solution &#123; int max = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) &#123; helper(root); return max; &#125; // helper returns the max branch // plus current node's value int helper(TreeNode root) &#123; if (root == null) return 0; int left = Math.max(helper(root.left), 0); int right = Math.max(helper(root.right), 0); max = Math.max(max, root.val + left + right); return root.val + Math.max(left, right); &#125;&#125;// 链接：https://leetcode.com/problems/binary-tree-maximum-path-sum/discuss/39875/Elegant-Java-solution 虽然还不是很懂这两行 123max = Math.max(max, root.val + left + right);return root.val + Math.max(left, right);]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-117 Populating Next Right Pointers in Each Node II]]></title>
    <url>%2F2020%2F04%2F09%2FLeetCode-117%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Follow up: You may only use constant extra space. Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem. Example 1: 123Input: root = [1,2,3,4,5,null,7]Output: [1,#,2,3,#,4,5,7,#]Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &apos;#&apos; signifying the end of each level. Constraints: The number of nodes in the given tree is less than 6000. -100 &lt;= node.val &lt;= 100 思路: ​ 用上一题的层次遍历的话貌似不需要改代码，说干就干，趁着记忆还热乎着，把116的代码码了一遍，由于手打还是出现了一些波折， 比如Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();少打了前面的&lt;Node&gt;，毕竟之前都是用IDEA，敲后面的new LinkedList&lt;Node&gt;();用快捷键自动生成前面。 再就是queue.size()少了(),还是同样的理由，之前都是自动补全的代码。 还有就是Node node = queue.poll();写在了for循环的外面。 最后就是node.next = queue.peek();不知道左边应该写什么。 大体上还是OK的，没有出现Runtime Exception，几个编译异常也都及时发现并解决了，没有出现找了很久没发现错哪的问题。 但是层级遍历的空间复杂度为，并不符合题目的进阶要求。 层级遍历: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node next; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val, Node _left, Node _right, Node _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123; public Node connect(Node root) &#123; if (root == null)&#123; return null; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); queue.offer(root); while (queue.size() &gt; 0)&#123; int size = queue.size(); for (int i = 0; i &lt; size; i++)&#123; Node node = queue.poll(); if (i &lt; size -1)&#123; node.next = queue.peek(); &#125; if (node.left != null)&#123; queue.add(node.left); &#125; if (node.right != null)&#123; queue.add(node.right); &#125; &#125; &#125; return root; &#125;&#125; 空间复杂度为的方法还没仔细看，感觉挺复杂的，也贴一下吧。 1234567891011121314151617181920212223242526public class Solution &#123; public void connect(TreeLinkNode root) &#123; if (root == null) return; TreeLinkNode curP = root; TreeLinkNode nextDummyHead = new TreeLinkNode(0); TreeLinkNode p = nextDummyHead; while (curP != null) &#123; if (curP.left != null) &#123; p.next = curP.left; p = p.next; &#125; if (curP.right != null) &#123; p.next = curP.right; p = p.next; &#125; if (curP.next != null) &#123; curP = curP.next; &#125; else &#123; curP = nextDummyHead.next; nextDummyHead.next = null; p = nextDummyHead; &#125; &#125; &#125;&#125; 链接：https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/discuss/37828/O(1)-space-O(n)-complexity-Iterative-Solution]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-116 Populating Next Right Pointers in Each Node]]></title>
    <url>%2F2020%2F04%2F09%2FLeetCode-116%2F</url>
    <content type="text"><![CDATA[Level: Medium You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Follow up: You may only use constant extra space. Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem. Example 1: 123Input: root = [1,2,3,4,5,6,7]Output: [1,#,2,3,#,4,5,6,7,#]Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &apos;#&apos; signifying the end of each level. Constraints: The number of nodes in the given tree is less than 4096. -1000 &lt;= node.val &lt;= 1000 个人思路: ​ 层次遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node next; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val, Node _left, Node _right, Node _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123; public Node connect(Node root) &#123; if (root == null)&#123; return root; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); queue.offer(root); while(queue.size() &gt; 0 &amp;&amp; queue != null)&#123; int size = queue.size(); for(int i = 0; i &lt; size; i++)&#123; Node node = queue.poll(); if (i &lt; size - 1) &#123; node.next = queue.peek(); &#125; if (node.left != null)&#123; queue.offer(node.left); &#125; if (node.right != null)&#123; queue.offer(node.right); &#125; &#125; &#125; return root; &#125; &#125; 我的版本少了如下这一段，导致报错。 if (i &lt; size - 1) { node.next = queue.peek(); }还有一种更优雅的方法，不过单看代码不容易理解 1234567891011121314151617public class Solution &#123; public void connect(TreeLinkNode root) &#123; TreeLinkNode level_start=root; while(level_start!=null)&#123; TreeLinkNode cur=level_start; while(cur!=null)&#123; if(cur.left!=null) cur.left.next=cur.right; if(cur.right!=null &amp;&amp; cur.next!=null) cur.right.next=cur.next.left; cur=cur.next; &#125; level_start=level_start.left; &#125; &#125;&#125;链接：https://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/37461/Java-solution-with-O(1)-memory%2B-O(n)-time 搭配图解更方便理解，以下节选自力扣中国 链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/solution/tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-j-3/ 方法二：使用已建立的 next 指针思路 一棵树中，存在两种类型的 next 指针。 第一种情况是连接同一个父节点的两个子节点。它们可以通过同一个节点直接访问到，因此执行下面操作即可完成连接。 1node.left.next = node.right 第二种情况在不同父亲的子节点之间建立连接，这种情况不能直接连接。 如果每个节点有指向父节点的指针，可以通过该指针找到 `next` 节点。如果不存在该指针，则按照下面思路建立连接： 第 N 层节点之间建立 next 指针后，再建立第 N+1 层节点的 next 指针。可以通过 next 指针访问同一层的所有节点，因此可以使用第 N 层的 next 指针，为第 N+1 层节点建立 next 指针。 算法 从根节点开始，由于第 0 层只有这一个节点，所以不需要连接。直接为第 1 层节点建立 next 指针即可。该算法中需要注意的一点是，当我们为第 N 层节点建立 next 指针时，处于第 N-1N−1 层。当第 NN 层节点的 next 指针全部建立完成后，移至第 NN 层，建立第 N+1N+1 层节点的 next 指针。 遍历某一层的节点时，这层节点的 next 指针已经建立。因此我们只需要知道这一层的最左节点，就可以按照链表方式遍历，不需要使用队列。 上面思路的伪代码如下： 123456789101112leftmost = rootwhile (leftmost.left != null)&#123; head = leftmost while (head.next != null) &#123; 1) Establish Connection 1 2) Establish Connection 2 using next pointers head = head.next &#125; leftmost = leftmost.left&#125; 两种类型的 next 指针， 第一种情况两个子节点属于同一个父节点，因此直接通过父节点建立两个子节点的 next 指针即可。 1node.left.next = node.right 第二种情况是连接不同父节点之间子节点的情况。更具体地说，连接的是第一个父节点的右孩子和第二父节点的左孩子。由于已经在父节点这一层建立了 next 指针，因此可以直接通过第一个父节点的 next 指针找到第二个父节点，然后在它们的孩子之间建立连接。 1node.right.next = node.next.left 完成当前层的连接后，进入下一层重复操作，直到所有的节点全部连接。进入下一层后需要更新最左节点，然后从新的最左节点开始遍历该层所有节点。因为是完美二叉树，因此最左节点一定是当前层最左节点的左孩子。如果当前最左节点的左孩子不存在，说明已经到达该树的最后一层，完成了所有节点的连接。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public Node connect(Node root) &#123; if (root == null) &#123; return root; &#125; // Start with the root node. There are no next pointers // that need to be set up on the first level Node leftmost = root; // Once we reach the final level, we are done while (leftmost.left != null) &#123; // Iterate the "linked list" starting from the head // node and using the next pointers, establish the // corresponding links for the next level Node head = leftmost; while (head != null) &#123; // CONNECTION 1 head.left.next = head.right; // CONNECTION 2 if (head.next != null) &#123; head.right.next = head.next.left; &#125; // Progress along the list (nodes on the current level) head = head.next; &#125; // Move onto the next level leftmost = leftmost.left; &#125; return root; &#125;&#125; ps:排版真费时间呀]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-114 Flatten Binary Tree to Linked List]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-114%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 12345 1 / \ 2 5 / \ \3 4 6 The flattened tree should look like: 12345678910111 \ 2 \ 3 \ 4 \ 5 \ 6 思路: ​ 一开始还以为是把树转成LinkedList，想着还挺简单，弄个先序遍历add进去就完事了。后来才发现理解错题意了。 代码: 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private TreeNode prev = null; public void flatten(TreeNode root) &#123; if (root == null)&#123; return; &#125; flatten(root.right); flatten(root.left); root.right = prev; root.left = null; prev = root; &#125;&#125; 看见这种特别短的代码就头疼，没搞清楚递归的执行顺序，导致看不懂。今天先不做了，消化一下，没弄懂的地方还很多。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-113 Path Sum II]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-113%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 1234567 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1 Return: 1234[ [5,4,11,2], [5,8,4,5]] 思路: ​ 和上一题类似，DFS先序遍历，建一个二维数组，遍历的时候add进去，但是具体代码写不出来，还是会卡住。 代码: 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; current = new ArrayList&lt;Integer&gt;(); return helper(root,sum,result,current); &#125; public List&lt;List&lt;Integer&gt;&gt; helper(TreeNode root,int sum,List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; current)&#123; if (root == null)&#123; return result; &#125; current.add(root.val); if (root.left == null &amp;&amp; root.right == null &amp;&amp; sum == root.val)&#123; result.add(new ArrayList(current)); &#125; helper(root.left,sum -root.val,result,current); helper(root.right,sum -root.val,result,current); current.remove(current.size()-1); return result; &#125;&#125; 递归这块还是有些薄弱，其实还是没能彻底弄懂递归的原理，不过比起几天前有进步了，之前连思路都没有。现在好歹有思路了，只是写不出来。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-112 Path Sum]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-112%2F</url>
    <content type="text"><![CDATA[Level: Easy Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 1234567 5 / \ 4 8 / / \ 11 13 4 / \ \7 2 1 return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 123456789101112131415161718/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if(root == null) return false; if(root.left == null &amp;&amp; root.right == null) return sum == root.val; return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); &#125;&#125; 为啥有时候Easy的题目也做不出来。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-111 Minimum Depth of Binary Tree]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-111%2F</url>
    <content type="text"><![CDATA[Level: Easy Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its minimum depth = 2. 自己的解 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int minDepth(TreeNode root) &#123; int depth = 1; if (root == null)&#123; return 0; &#125; return helper(root,depth); &#125; public int helper(TreeNode root,int depth)&#123; depth ++; if (root.left != null)&#123; helper(root.left,depth); &#125; if(root.right != null)&#123; helper(root.right,depth); &#125; return depth; &#125;&#125; 然而是错的。 正确答案: 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int minDepth(TreeNode root) &#123; if (root == null)&#123; return 0; &#125; return helper(root); &#125; public int helper(TreeNode root)&#123; if (root.left == null) &#123; return minDepth(root.right) + 1; &#125; if (root.right == null) &#123; return minDepth(root.left) + 1; &#125; return Math.min(minDepth(root.left),minDepth(root.right)) + 1; &#125;&#125; 大体框架上是对了，但是细节还是不对，还是很菜。。。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-110 Balanced Binary Tree]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-110%2F</url>
    <content type="text"><![CDATA[Level: Easy Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Example 1: Given the following tree [3,9,20,null,null,15,7]: 12345 3 / \9 20 / \ 15 7 Return true. Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]: 1234567 1 / \ 2 2 / \ 3 3 / \4 4 思路: ​ 个人想法，DFS然后用一个变量记录高度，看了评论区发现并没有这样的实现。 为什么难度为Easy的题目我却看不懂。 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isBalanced(TreeNode root) &#123; if(root == null)&#123; return true; &#125; return helper(root) != -1; &#125; private int helper(TreeNode root)&#123; if(root == null)&#123; return 0; &#125; int left = helper(root.left); int right = helper(root.right); if(left == -1 || right == -1 || Math.abs(left - right) &gt; 1)&#123; return -1; &#125; return Math.max(left, right) + 1; &#125;&#125; 可能是对高度不熟吧，第一次碰见高度的题。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-108 Convert Sorted Array to Binary Search Tree]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-108%2F</url>
    <content type="text"><![CDATA[Level: Easy Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted array: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 思路: ​ 先找出根节点，再分别构建左右子树。由于是排序好的Array，那么数组中间的数就是这棵树的根节点。int middle = start + (end-start)/2;和int middle = (start+end)/2;后一种写法可能会造成integer overflow，为了避免这个应该尽量使用第一种。 解: 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; if (nums.length == 0 || nums == null)&#123; return null; &#125; return helper(nums,0,nums.length -1); &#125; public TreeNode helper(int[] nums, int start, int end)&#123; if (start &gt; end)&#123; return null; &#125; int middle = start + (end-start)/2; TreeNode node = new TreeNode(nums[middle]); node.left = helper(nums, start, middle -1); node.right = helper(nums, middle+1, end); return node; &#125;&#125; 写树的算法，渐渐的有些感觉了。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-107 Binary Tree Level Order Traversal II]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-107%2F</url>
    <content type="text"><![CDATA[Level: Easy Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its bottom-up level order traversal as: 12345[ [15,7], [9,20], [3]] 类似于之前的102题，奇怪的是，102难度为Medium，而这题难度为Easy。 不过有点记不清之前的思路了，只记得用了Queue，利用Queen FIFO的特性。而这题可以用Stack，LIFO。 不过Stack没怎么玩过，看了眼评论区，发现还是用的Queue，最后add的时候用的是list.add(0,item);看到这终于弄懂了之前Z形层次遍历产生的一个疑问，也就是当时list.add(0,xx);的作用。之前一直以为如果add的地方原本有值，会把原来的值给覆盖掉，所以之前看到的时候没有搞懂这种写法。 有用的知识增加了.jpg 解: 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (root == null) &#123; return result; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; List&lt;Integer&gt; level = new ArrayList&lt;Integer&gt;(); int level_lengh = queue.size(); for (int i = 0; i &lt; level_lengh; i++) &#123; TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) &#123; queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; &#125; result.add(0, level); &#125; return result; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-106 Construct Binary Tree from Inorder and Postorder Traversal]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-106%2F</url>
    <content type="text"><![CDATA[Level: Medium Given inorder and postorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given 12inorder = [9,3,15,20,7]postorder = [9,15,7,20,3] Return the following binary tree: 12345 3 / \9 20 / \ 15 7 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] inorder, int[] postorder) &#123; if (inorder == null || postorder == null || inorder.length != postorder.length) &#123; return null; &#125; Map&lt;Integer, Integer&gt; inMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; inorder.length; i++) &#123; inMap.put(inorder[i], i); &#125; return buildTreeHelper(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1, inMap); &#125; public TreeNode buildTreeHelper(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd, Map&lt;Integer, Integer&gt; inMap) &#123; if (inStart &gt; inEnd || postStart &gt; postEnd) &#123; return null; &#125; TreeNode root = new TreeNode(postorder[postEnd]); int numerLeft = inMap.get(postorder[postEnd]); root.left = buildTreeHelper(inorder, inStart, numerLeft - 1, postorder, postStart, postStart + numerLeft - inStart - 1, inMap); root.right = buildTreeHelper(inorder, numerLeft + 1, inEnd, postorder, postStart + numerLeft - inStart, postEnd - 1, inMap); return root; &#125; &#125; 对于左右子树索引的计算和传入还有些困惑，例如 1postStart + numerLeft - inStart - 1 和 1postStart + numerLeft - inStart 下次再做一遍，加深理解。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 105 Construct Binary Tree from Preorder and Inorder Traversal]]></title>
    <url>%2F2020%2F04%2F03%2FLeetCode-105%2F</url>
    <content type="text"><![CDATA[Level: Medium Construct Binary Tree from Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given 12preorder = [3,9,20,15,7]inorder = [9,3,15,20,7] Return the following binary tree: 12345 3 / \9 20 / \ 15 7 思路： ​ 没有 阅读理解 方法1 12345678910111213141516171819public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return helper(0, 0, inorder.length - 1, preorder, inorder);&#125;public TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) &#123; if (preStart &gt; preorder.length - 1 || inStart &gt; inEnd) &#123; return null; &#125; TreeNode root = new TreeNode(preorder[preStart]); int inIndex = 0; // Index of current root in inorder for (int i = inStart; i &lt;= inEnd; i++) &#123; if (inorder[i] == root.val) &#123; inIndex = i; &#125; &#125; root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder); root.right = helper(preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder); return root;&#125; 方法2 1234567891011121314151617181920212223public TreeNode buildTree(int[] preorder, int[] inorder) &#123; Map&lt;Integer, Integer&gt; inMap = new HashMap&lt;Integer, Integer&gt;(); for(int i = 0; i &lt; inorder.length; i++) &#123; inMap.put(inorder[i], i); &#125; TreeNode root = buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, inMap); return root;&#125;public TreeNode buildTree(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd, Map&lt;Integer, Integer&gt; inMap) &#123; if(preStart &gt; preEnd || inStart &gt; inEnd) return null; TreeNode root = new TreeNode(preorder[preStart]); int inRoot = inMap.get(root.val); int numsLeft = inRoot - inStart; root.left = buildTree(preorder, preStart + 1, preStart + numsLeft, inorder, inStart, inRoot - 1, inMap); root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd, inorder, inRoot + 1, inEnd, inMap); return root;&#125; 方法3 12345678910111213141516171819 public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if(preorder.length!=inorder.length) return null; return build(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1);&#125;public TreeNode build(int [] preorder, int preLow, int preHigh, int[] inorder, int inLow, int inHigh)&#123; if(preLow&gt;preHigh || inLow&gt;inHigh) return null; TreeNode root = new TreeNode(preorder[preLow]); int inorderRoot = inLow; for(int i=inLow;i&lt;=inHigh;i++)&#123; if(inorder[i]==root.val)&#123; inorderRoot=i; break; &#125; &#125; int leftTreeLen = inorderRoot-inLow; root.left = build(preorder, preLow+1, preLow+leftTreeLen, inorder, inLow, inorderRoot-1); root.right = build(preorder, preLow+leftTreeLen+1, preHigh, inorder, inorderRoot+1, preHigh); return root; &#125; 这几个方法思路是一样的，区别在于获取中序遍历root位于数组中的index的方法不同，一个用了遍历，一个用了HashMap，当然几个都有一个共同的前提，数组里没有重复的数。 看了很久的代码，大致上明白了，总的思路如下: 前序遍历的第一位一定是树的根节点，根据这个特性我们可以知道这棵树的根节点，进一步可以知道中序数组中根节点的位置。 中序遍历的特点是根节点左边为左子树，右边为右子树。 结合这两点可以知道这棵树左右节点的数量。 找到各个子树的根节点 root 构建该根节点的左子树 构建该根节点的右子树 自以为看懂了，去做106，结果做到关键地方还是卡住了，不知道是应该加还是减，说明还是没完全搞懂，先消化一下，明天再做106吧。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-104 Maximum Depth of Binary Tree]]></title>
    <url>%2F2020%2F04%2F02%2FLeetCode-104%2F</url>
    <content type="text"><![CDATA[Maximum Depth of Binary Tree Level: Easy Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its depth = 3. 思路: ​ 这题比较简单，用递归实现，中途想像平常的DFS一样直接return，想了想发现不行，然后卡了会。得把左右都算出来，比较一下，深度再加1。 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if (root == null)&#123; return 0; &#125; int left = 0; int right = 0; if (root.left != null)&#123; left = maxDepth(root.left); &#125; if (root.right != null)&#123; right = maxDepth(root.right); &#125; return left&gt;=right?left+1:right+1; &#125;&#125; 总体写下来还比较顺，没用idea，页面里纯手写，一次编译运行通过。虽然是个Easy难度的题目，但还是能感受到因为进步带来的小小的成就感。 提交完，照旧看了下讨论区。发现别人只要一行就实现了，淦。 1234567public class Solution &#123; public int maxDepth(TreeNode root) &#123; return root==null? 0 : Math.max(maxDepth(root.left), maxDepth(root.right))+1; &#125;&#125;//https://leetcode.com/problems/maximum-depth-of-binary-tree/discuss/34216/Simple-solution-using-Java// author:dennyrong 看了下，大致 的思路是一样的。三元运算符我也用到了，只不过真没想过用Math.max()这个函数，还是得继续努力呀。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-103 Binary Tree Zigzag Level Order Traversal]]></title>
    <url>%2F2020%2F04%2F02%2FLeetCode-103%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] 思路: ​ 题目的需求跟102题很相似，第一反应就是先照着102写，然后在这个基础之上改改。主要是想着改下面这一段，左改右，右改左之类的。 123456if (node.left != null) &#123; queue.add(node.left);&#125;if (node.right != null) &#123; queue.add(node.right);&#125; 而然改了半天，发现做不到题目要求的效果。于是乎又求助评论区。果然在原有的基础上加了个标志位，并且新增了一段 123456if (zigzag) &#123; level.add(0, node.val);&#125;else &#123; level.add(node.val);&#125; 这个代码后，就能符合题目的要求了，和我心里的预期是相符的。 但是没看懂这一段的意义，就去了leetcode cn，希望能找个中文的思路看下。结果让我没想到的是，力扣中国这题的写法居然完全换了一种思路。属实8行。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-102 Binary Tree Level Order Traversal]]></title>
    <url>%2F2020%2F04%2F02%2FLeetCode-102%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] 思路: ​ 层次遍历。 ​ 然而不会写层次遍历，于是直奔评论区，找了个最高赞的答案看了看，大致上看懂了。 算法上面的递归方法也可以写成迭代的形式。我们将树上顶点按照层次依次放入队列结构中，队列中元素满足 FIFO（先进先出）的原则。在 Java 中可以使用 Queue 接口中的 LinkedList实现。在 Python 中如果使用 Queue 结构，但因为它是为多线程之间安全交换而设计的，所以使用了锁，会导致性能不佳。因此在 Python 中可以使用 deque 的 append() 和 popleft() 函数来快速实现队列的功能。第 0 层只包含根节点 root ，算法实现如下：初始化队列只包含一个节点 root 和层次编号 0 ： level = 0。当队列非空的时候：在输出结果 levels 中插入一个空列表，开始当前层的算法。计算当前层有多少个元素：等于队列的长度。将这些元素从队列中弹出，并加入 levels 当前层的空列表中。将他们的孩子节点作为下一层压入队列中。进入下一层 level++。 实现 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (root == null) return levels; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); int level = 0; while ( !queue.isEmpty() ) &#123; // start the current level levels.add(new ArrayList&lt;Integer&gt;()); // number of elements in the current level int level_length = queue.size(); for(int i = 0; i &lt; level_length; ++i) &#123; TreeNode node = queue.remove(); // fulfill the current level levels.get(level).add(node.val); // add child nodes of the current level // in the queue for the next level if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); &#125; // go to next level level++; &#125; return levels; &#125;&#125;/*** https://leetcode-cn.com/problems/binary-tree-level-order-* traversal/solution/er-cha-shu-de-ceng-ci-bian-li-by-leetcode/*/ 方法2: 123456789101112131415161718192021222324List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; List&lt;Integer&gt; level = new ArrayList&lt;&gt;(); int cnt = queue.size(); for (int i = 0; i &lt; cnt; i++) &#123; TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) &#123; queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; &#125; res.add(level); &#125; return res;/*** https://leetcode.com/problems/binary-tree-level-order-* traversal/discuss/33450/Java-solution-with-a-queue-used*/]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-101 Symmetric Tree Easy]]></title>
    <url>%2F2020%2F04%2F01%2FLeetCode-101%2F</url>
    <content type="text"><![CDATA[Symmetric Tree Level:Easy 题目: Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 12345 1 / \ 2 2 / \ / \3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 12345 1 / \2 2 \ \ 3 3 Note:Bonus points if you could solve it both recursively and iteratively. 思路，迭代判断第一层是否为空，第二层左右节点是否相等，第三层左子树的左节点是否等于右子树的右节点，并且左子树的右节点是否等于右子树的左节点。 完整代码: 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if (root == null) &#123; return true; &#125; return helper(root.left, root.right); &#125; public boolean helper(TreeNode left, TreeNode right) &#123; if (left == null || right == null) &#123; return left == right; &#125; if (left.val != right.val) &#123; return false; &#125; return helper(left.left, right.right) &amp;&amp; helper(left.right, right.left); &#125;&#125; 太冤了，今天复习的时候root == null我return false，submit的时候遇到test case: []居然算我错了，按题意null的时候应该返回ture，太扯了，空的树也算对称的吗？因为这个降低了accept率太亏了。 复习: Time Submitted Status Runtime Memory Language 4 minutes ago Accepted 1 ms 39.2 MB java 5 minutes ago Wrong Answer N/A N/A java 8 days ago Accepted 0 ms 37.7 MB java 9 days ago Accepted 0 ms 38 MB java Last update time: 2020年4月10日 15点19分]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-100 Same Tree]]></title>
    <url>%2F2020%2F04%2F01%2FLeetCode-100%2F</url>
    <content type="text"><![CDATA[Same Tree Level:Easy 题目: Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: 1234567Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]Output: true Example 2: 1234567Input: 1 1 / \ 2 2 [1,2], [1,null,2]Output: false Example 3: 1234567Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2]Output: false 解答: 脑海里的第一个想法就是遍历两棵树，然后比较相同节点的大小，但凡有一个不相等就说明不是同样的树。具体思路: 首先判断两个节点是否为空 123456if(p==null&amp;&amp;q==null)&#123; return true;&#125;if(p!=null||q!=null)&#123; return false;&#125; 然后对比根节点root，根节点不同直接返回false，根节点相同再判断左右子节点。 12345if(p.val==q.val)&#123; return isSameTree(p.left==q.left)&amp;&amp;isSameTree(p.right==q.right);&#125;else&#123; return false;&#125; 完整代码 123456789101112131415161718192021/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if (p == null || q == null) &#123; return (p==q); &#125; if (p.val == q.val) &#123; return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); &#125; else &#123; return false; &#125; &#125;&#125; 复习: Time Submitted Status Runtime Memory Language a few seconds ago Accepted 0 ms 36.9 MB java 9 days ago Accepted 0 ms 37.5 MB java Last update time : 2020年4月10日 14点50分 9天前，解法已经有些模糊了，勉勉强强写出了个框架，但是没弄通过。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移民计划]]></title>
    <url>%2F2020%2F04%2F01%2F%E7%A7%BB%E6%B0%91%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[移民 加拿大 移民快速通道 Express Entry基本要求 打算居住在魁北克以外的省份； 过去10年内，有带薪的、一年以上的连续的全职（或等同的兼职）工作，从事同一个职业，在NOC 0，A或者B类别中； 英语或法语至少达到CLB 7级（雅思4个6）； 六项打分超过67。 年龄: 27(30岁一下最高分) 12分学历: 本科 21分(博士25(满分),硕士23(看能不能弄个硕士学位))雅思: 6/6/6/6 16分工作: 5 年 13分(满分15 6年)单身: 0总: 62分数不够入池,除非找个女朋友或者雅思7 联邦技术移民 Federal Skilled Workers总分336差的太多 安省优才计划 – 快速通道NSNP新斯科舍省提名移民项目 - NSNP紧缺职业EE类别 - Catogory B不需要雇主offer SINP萨省提名移民项目 - 2019- 萨省无雇主技术移民项目 SINP 技术移民EE类别（International Skilled Worker: Saskatchewan Express Entry） SINP 技术移民OID类别（International Skilled Worker: Occupation In-Demand） SINP EE类别申请条件 - 飞出国SINP技术移民EE类别要求申请人的职业在萨省紧缺职业列表当中，首先需满足联邦技术移民67分评分标准进入EE池，这也就意味着该类申请人雅思需要达到4个6的成绩，同时还需满足SINP评分60分的标准。 成功创建EE，并进入EE候选池，获得EE账户号码（Express Entry profile Number）和求职验证代码（Job Seeker Validation Code）； 获得SINP萨省技术移民评分标准100分中的60分； 提供指定考试机构出具的有效语言考试成绩，考试成绩应与EE账户中所提交的成绩相匹配； 完成与加拿大教育体系相匹配的至少一年的高等教育、培训或学徒期，并获得文凭、证书或学位； 海外学历申请人需通过指定机构的ECA学历认证； 申请人的专业或受训职业必须符合以下所列条件之一： 过去10年中至少1年非技工类有偿工作经验； 过去5年中至少2年技工类有偿工作经验；或 过去3年中至少12个月加拿大工作经验（技工类或非技工类均可）； 职业必须在萨省紧缺职业列表当中，并且属于NOC 0、A、B类； 如果申请人的职业在萨省为受管制职业，则需首先通过萨省认证，才能提交移民申请； 具备充足的安家资金及定居计划。 SINP OID类别申请条件 - 飞出国SINP技术移民OID类别要求申请人的职业在萨省紧缺职业列表当中，满足SINP评分60分的标准，其中语言打分与EE类别略有不同，OID类别语言达到CLB 4即可得到12分加分，这一标准不适用于EE类别，因此许多雅思无法达到4个6的申请人，只要其他条件满足即可通过该途径申请移民。 获得SINP萨省技术移民评分标准100分中的60分； 语言至少达到CLB4，雇主和监管机构可能会要求更高的语言成绩； 完成与加拿大教育体系相匹配的至少一年的高等教育、培训或学徒期，并获得文凭、证书或学位； 海外学历申请人需通过指定机构的ECA学历认证； 过去十年内具备至少一年相关工作经验，职业类别属于NOC 0、A和B类； 如果申请人的职业在萨省为受管制职业，则需首先通过萨省认证，才能提交移民申请； 具备充足的安家资金及定居计划。 杂QSW 魁省，20180802后实施高分选，法语将变的最重要，其次是魁北克学历且高分专业，再次是有job offer的，三者有2项以上的基本无悬念。需要法语好或专业好，最新受训加分调整，计算机,会计，航空航天，银行和金融，生物，土木建筑，地球，电子电气，食品，地质，水文，机械，护理，物理，植物，食品加工等只有9分。 SINP 萨省，20180716后改为 EOI 择优选，第一次邀请68分，有萨省亲属，有萨省留学和工作经验的申请人更占优势。分为EE和OID（非EE）两种类型，雅思要求低，适合工作经验久的申请人，热门紧缺职业：工程师经理，土木、计算机软硬件工程师，农业，园林，电子维修，经济学家可以申请； NSNP 新省，当前还是抢配额，2018年只开放一次，当前只有EE，核心紧缺职业：金融审计会计，广告，市场，公关，行政助理，财务出纳，土木工程，护士，大专院校讲师，社工，抢配额工作量大，而且职业清单和申请流程说变就变；另外20180802 NS LMP 增加了直接去EE池子里挑选紧缺职业的类别。 OINP 安省 ，分为高分类别（HCP类EE分数400分以上有希望，偶尔有职业限制，当前邀请分数在430分以上，2018年4月后没有再邀请）和法语类别（法语B2，申请人少，无EE分数和配额限制）；安省认可大学的硕博可以无雇主offer移民，限定学校，学历，且需要毕业2年内申请 NBNP NB省，有直系亲属，法语好或参加过宣讲会且职业属于计算机，厨师，酒店餐饮服务经理，会计出纳，健康护理经理，零售主管等，需要满足加拿大联邦EE要求。 MPNP 曼省，有曼省紧缺职业工作经验且与曼省有紧密联系，包括曼省有亲戚朋友担保，有曼省留学、工作经验，有曼省自己的EOI评分，，分为 EE 和 HCP（非EE） PEIPNP PEI EE 类别允许无雇主offer，但要求与 PEI 有较紧密联系，例如PEI工作过，留学过，有亲属，有房产等，需要满足加拿大联邦EE要求 澳大利亚 技术移民 491]]></content>
      <tags>
        <tag>计划</tag>
        <tag>移民</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雅思备考计划]]></title>
    <url>%2F2020%2F03%2F25%2F%E9%9B%85%E6%80%9D%E5%A4%87%E8%80%83%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[计划 准备 iPad Pro 蹲一个教育优惠 剑桥雅思真题9-14? 4-9?4-14? 正版太贵，尽量支持正版吧，不行就盗版。 安静的地方，在附近物色一个图书馆，周末泡图书馆，6月房子到期，到时候还的重新找个。 图书馆的准备 水杯 iPad 手机 耳机 书 笔记本 笔 充电宝？ 包 一个一起学习的女朋友 干净的着装 时间安排合理利用工作的空余时间，上下班的通勤时间，以及周末和假期。上下班通勤时间2个小时左右。刨去走路和骑车所花的时间，单在地铁车厢里的时间保守估计有1小时30分左右。 周末: 9点，起床，半个小时洗漱，吃早餐 9点30 出门 到图书馆时间未定 12点吃饭 午休一小时 1点继续 5点吃晚饭 离开时间待定 更细致的安排待定，比如背单词多少分钟，写作多少分钟，听力多少分钟。待早期的摸索和后期的调整。 考虑是否应该设置休息日，还是说每日余下的时间作为休息就足够了。 目的听/读/写/说 8/7/7/7找一个志同道合的女朋友]]></content>
  </entry>
  <entry>
    <title><![CDATA[移民相关]]></title>
    <url>%2F2020%2F03%2F24%2F%E7%A7%BB%E6%B0%91%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[大学时的计划30岁之前移民的，不知不觉只剩5年了，再这样浑浑噩噩，感觉就实现不了了。 要开始做一些详细的准备了，暂定这几个国家(特地不加地区) 台湾：融入很方便 日本：职场压力比较大的样子 美国：最向往，技术移民太难，移民政策收紧，只能想着过去生个孩子，帮下一代弄个美国籍。 加拿大：天气有点冷，有百万移民的政策。 新西兰：听说四国里最简单的，优势是回头签。年龄和职业是优势，最大的问题是英语，雅思得7炸或者8炸。计划WHV签证落地，找工作换长期签证。可惜19年停止了银蕨签证，又少了个渠道。 澳大利亚：好像对华人不太友好。政策收紧，EOI分数要求越来越高。 希望能有个一起努力的女朋友，不知道txh愿不愿意移民。配偶英语不错也能加分。]]></content>
  </entry>
  <entry>
    <title><![CDATA[快乐周末]]></title>
    <url>%2F2019%2F12%2F21%2F%E5%BF%AB%E4%B9%90%E5%91%A8%E6%9C%AB%2F</url>
    <content type="text"><![CDATA[斯达拉斯达拉新西游记第七季 闲着干嘛呢 RM 炎炎消防队]]></content>
  </entry>
  <entry>
    <title><![CDATA[爱在黎明破晓前]]></title>
    <url>%2F2019%2F08%2F11%2F%E7%88%B1%E5%9C%A8%E9%BB%8E%E6%98%8E%E7%A0%B4%E6%99%93%E5%89%8D%2F</url>
    <content type="text"><![CDATA[以前对爱情期待的时候看了好多的爱情片，印象比较深刻的就是这部《爱在黎明破晓前》。 其实是个三部曲还有《爱在午夜黄昏后》《爱在午夜降临前》。 讲个两个陌生人相遇，相爱，分开，再相遇的故事。 两个互不相识的人相爱，真的很美好。]]></content>
  </entry>
  <entry>
    <title><![CDATA[用心良苦]]></title>
    <url>%2F2019%2F08%2F10%2F%E7%94%A8%E5%BF%83%E8%89%AF%E8%8B%A6%2F</url>
    <content type="text"><![CDATA[你说你 想要逃]]></content>
  </entry>
  <entry>
    <title><![CDATA[起风了]]></title>
    <url>%2F2019%2F08%2F09%2F%E8%B5%B7%E9%A3%8E%E4%BA%86%2F</url>
    <content type="text"><![CDATA[台风要来了，第一次经历台风呢。]]></content>
  </entry>
  <entry>
    <title><![CDATA[形势不对]]></title>
    <url>%2F2019%2F08%2F06%2F%E5%BD%A2%E5%8A%BF%E4%B8%8D%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[可惜没存款，不然换点美金。 现今之际，只能存点粮食，水，日常药品。]]></content>
  </entry>
  <entry>
    <title><![CDATA[健身记录]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%81%A5%E8%BA%AB%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[买的健身装备到了，今天开始健身，记录下身材的变化。 2019-08-06 健身0天： 一个月后再记录一次。 2019-08-11 健身第一天]]></content>
  </entry>
  <entry>
    <title><![CDATA[吉他练习]]></title>
    <url>%2F2019%2F08%2F04%2F%E5%90%89%E4%BB%96%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[2019-08-04 认识六线谱，了解弦和品，练习《小星星》。 2019-08-04 忙别的去了，练习《小星星》30分钟。每天最少1小时，明天补起来。 2020-05-02 终于会弹小星星了，接下来学和弦。买个拨片先。 2020-05-04 今天学了几个和弦，不知道明天还记得几个。]]></content>
  </entry>
  <entry>
    <title><![CDATA[好想哭一场]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%A5%BD%E6%83%B3%E5%93%AD%E4%B8%80%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[香港加油！]]></title>
    <url>%2F2019%2F06%2F16%2F%E9%A6%99%E6%B8%AF%E5%8A%A0%E6%B2%B9%EF%BC%81%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[感冒了]]></title>
    <url>%2F2019%2F05%2F04%2F%E6%84%9F%E5%86%92%E4%BA%86%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Japan]]></title>
    <url>%2F2019%2F04%2F04%2FJapan%2F</url>
    <content type="text"><![CDATA[哟嚯，约了朋友去日本玩。 顺便完成一起去日本的约定。 得先去办护照，和签证。 期待！ 未完待续。 update 2019-04-07 可惜，没有单反。一直想要个单反没舍得买，今年是没机会了/]]></content>
  </entry>
  <entry>
    <title><![CDATA[想早点离开]]></title>
    <url>%2F2019%2F02%2F24%2F%E6%83%B3%E6%97%A9%E7%82%B9%E7%A6%BB%E5%BC%80%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[有个特别想写的]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%9C%89%E4%B8%AA%E7%89%B9%E5%88%AB%E6%83%B3%E5%86%99%E7%9A%84%2F</url>
    <content type="text"><![CDATA[留到重要的日子吧，比如生日再写。 今天很开心，偶然的想起一段尘封的往事。得好好构思一下，再润润色，争取写的优美一些。]]></content>
  </entry>
  <entry>
    <title><![CDATA[好累不想写]]></title>
    <url>%2F2019%2F02%2F15%2F%E5%A5%BD%E7%B4%AF%E4%B8%8D%E6%83%B3%E5%86%99%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[爱情]]></title>
    <url>%2F2019%2F02%2F10%2F%E7%88%B1%E6%83%85%2F</url>
    <content type="text"><![CDATA[若不是因为爱着你 怎么会夜深还没睡意 每个念头都关於你 我想你 想你 好想你 ──莫文蔚 爱情]]></content>
      <categories>
        <category>我独自生活</category>
      </categories>
      <tags>
        <tag>我独自生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[弱智]]></title>
    <url>%2F2019%2F02%2F05%2F%E5%BC%B1%E6%99%BA%2F</url>
    <content type="text"><![CDATA[我是个弱智]]></content>
  </entry>
  <entry>
    <title><![CDATA[喝醉了]]></title>
    <url>%2F2019%2F02%2F02%2F%E5%96%9D%E9%86%89%E4%BA%86%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[回家]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%9B%9E%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[回家了，不来了 相亲，结婚]]></content>
      <categories>
        <category>我独自生活</category>
      </categories>
      <tags>
        <tag>我独自生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[想要幸福]]></title>
    <url>%2F2019%2F01%2F14%2F%E6%83%B3%E8%A6%81%E5%B9%B8%E7%A6%8F%2F</url>
    <content type="text"><![CDATA[都这么自律了 标准好男人，怎么就得不到幸福呢。 难道真的要变成坏男人，才会有女生死心塌地的喜欢吗。]]></content>
      <categories>
        <category>我独自生活</category>
      </categories>
      <tags>
        <tag>我独自生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加班到最后一个人]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%8A%A0%E7%8F%AD%E5%88%B0%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[也算是难得的经历了]]></content>
      <categories>
        <category>我独自生活</category>
      </categories>
      <tags>
        <tag>我独自生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[啊，失眠了]]></title>
    <url>%2F2019%2F01%2F06%2F%E5%95%8A%EF%BC%8C%E5%A4%B1%E7%9C%A0%E4%BA%86%2F</url>
    <content type="text"><![CDATA[打哈欠 都不知道昨天几点睡着的，可能4点，可能5点。 心里莫名烦躁呢。]]></content>
      <categories>
        <category>我独自生活</category>
      </categories>
      <tags>
        <tag>我独自生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[答应不爱你]]></title>
    <url>%2F2018%2F10%2F07%2F%E7%AD%94%E5%BA%94%E4%B8%8D%E7%88%B1%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[虽然很努力练习着忘记我的心却还没答应可以放弃了你 ──答应不爱你 郑中基 明明爱很清晰却又接受分离我只剩思念的权利难过还来不及爱早已融入呼吸不存在的存在心底虽然很努力练习着忘记我的心却还没答应可以放弃了你真的对不起答应了你不再爱你我却还没答应我自己明明爱很清晰却要接受分离我只剩思念的权利难过还来不及就让爱融入空气不存在的存在心底说好要忘记偏偏又想起原来我的心还没有答应放弃了你真的对不起虽然曾经答应了你我却还没答应我自己却又如何真的不爱你──答应不爱你 郑中基]]></content>
      <categories>
        <category>听歌</category>
      </categories>
      <tags>
        <tag>听歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样]]></title>
    <url>%2F2018%2F10%2F06%2F%E6%80%8E%E6%A0%B7%2F</url>
    <content type="text"><![CDATA[如果我们现在还在一起会是怎样我们是不是还是深爱着对方 ──怎样 戴佩妮 我这里天快要黑了那里呢我这里天气凉凉的那里呢我这里一切都变了我变的懂事了我又开始写日记了而那你呢我这里天快要亮了那里呢我这里天气很炎热那里呢我这里一切都变了我变的不哭了我把照片也收起了而那你呢如果我们现在还在一起会是怎样我们是不是还是深爱着对方像开始时那样握着手就算天快亮我们现在还在一起会是怎样我们是不是还是隐瞒着对方像结束时那样明知道你没有错还硬要我原谅我这里天快要亮了那里呢我这里天气很炎热那里呢我这里一切都变了我变的不哭了我把照片也收起了而那你呢如果我们现在还在一起会是怎样我们是不是还是深爱着对方像开始时那样握着手就算天快亮我们现在还在一起会是怎样我们是不是还是隐瞒着对方像结束时那样明知道你没有错还硬要我原谅如果我们现在还在一起会是怎样我们是不是还是深爱着对方像开始时那样握着手就算天快亮我们现在还在一起会是怎样我们是不是还是隐瞒着对方像结束时那样明知道你没有错还硬要我原谅我不会原谅我怎么原谅──怎样 戴佩妮]]></content>
      <categories>
        <category>听歌</category>
      </categories>
      <tags>
        <tag>听歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[退后]]></title>
    <url>%2F2018%2F10%2F02%2F%E9%80%80%E5%90%8E%2F</url>
    <content type="text"><![CDATA[我知道我们都没有错 只是放手会比较好过 ──周杰伦 退后 天空灰的像哭过离开你以后并没有 更自由酸酸的空气嗅出我们的距离一幕锥心的结局像呼吸般无法停息抽屉泛黄的日记榨干了回忆那笑容 是夏季你我的过去被顺时针的忘记缺氧过后的爱情粗心的眼泪是多余我知道你我都没有错只是忘了怎么退后信誓旦旦给了承诺却被时间扑了空我知道我们都没有错只是放手会比较好过最美的爱情回忆里待续天空灰的像哭过离开你以后并没有 更自由酸酸的空气嗅出我们的距离一幕锥心的结局像呼吸般无法停息抽屉泛黄的日记榨干了回忆那笑容 是夏季你我的过去被顺时针的忘记缺氧过后的爱情粗心的眼泪是多余我知道你我都没有错只是忘了怎么退后信誓旦旦给了承诺却被时间扑了空我知道我们都没有错只是放手会比较好过最美的爱情回忆里待续我知道你我都没有错只是忘了怎么退后信誓旦旦给了承诺却被时间扑了空我知道我们都没有错只是放手会比较好过最美的爱情回忆里待续──周杰伦 退后]]></content>
      <categories>
        <category>听歌</category>
      </categories>
      <tags>
        <tag>听歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记事本]]></title>
    <url>%2F2018%2F10%2F01%2F%E8%AE%B0%E4%BA%8B%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[我看见自己写下的心情 把自己放在卑微的后头 ──周传雄 记事本 翻开随身携带的记事本写着许多事都是关于你你讨厌被冷落习惯被守候寂寞才找我我看见自己写下的心情把自己放在卑微的后头等你等太久想你泪会流而幸福快乐是什么爱的痛了痛的哭了哭的累了日记本里页页执着记载着你的好像上瘾的毒药它反覆骗着我爱的痛了痛的哭了哭的累了矛盾心里总是强求劝自己要放手闭上眼让你走烧掉日记重新来过我看见自己写下的心情把自己放在卑微的后头等你等太久想你泪会流而幸福快乐是什么爱的痛了痛的哭了哭的累了日记本里页页执着记载着你的好像上瘾的毒药它反复骗着我爱的痛了痛的哭了哭的累了矛盾心里总是强求劝自己要放手闭上眼让你走烧掉日记重新来过爱的痛了痛的哭了哭的累了矛盾心里总是强求劝自己要放手闭上眼让你走烧掉日记重新来过──周传雄 记事本]]></content>
      <categories>
        <category>听歌</category>
      </categories>
      <tags>
        <tag>听歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开不了口]]></title>
    <url>%2F2018%2F09%2F30%2F%E5%BC%80%E4%B8%8D%E4%BA%86%E5%8F%A3%202%2F</url>
    <content type="text"><![CDATA[才离开没多久就开始 担心今天的你过得好不好 ──周杰伦 开不了口 才离开没多久就开始担心今天的你过得好不好整个画面是你 想你想的睡不着嘴嘟嘟那可爱的模样还有在你身上香香的味道我的快乐是你 想你想的都会笑没有你在我有多难熬（没有你在我有多难熬多烦恼）没有你烦我有多烦恼（没有你烦我有多烦恼多难熬）穿过云层 我试着努力向你奔跑爱才送到 你却已在别人怀抱就是开不了口 让她知道我一定会呵护着你 也逗你笑你对我有多重要我后悔没 让你知道安静的听你撒娇看你睡着 一直到老就是开不了口 让她知道就是那么简单几句 我办不到整颗心悬在半空我只能够 远远看着这些我都做得到但那个人已经不是我没有你在我有多难熬（没有你在我有多难熬多烦恼）没有你烦我有多烦恼（没有你烦我有多烦恼多难熬）穿过云层 我试着努力向你奔跑爱才送到 你却已在别人怀抱就是开不了口 让她知道我一定会呵护着你 也逗你笑你对我有多重要我后悔没 让你知道安静的听你撒娇看你睡着 一直到老就是开不了口 让她知道就是那么简单几句 我办不到整颗心悬在半空我只能够 远远看着这些我都做得到但那个人已经不是我──周杰伦 开不了口]]></content>
      <categories>
        <category>听歌</category>
      </categories>
      <tags>
        <tag>听歌</tag>
      </tags>
  </entry>
</search>
