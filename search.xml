<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一件搞笑的事]]></title>
    <url>%2F2020%2F04%2F08%2F%E4%B8%80%E4%BB%B6%E6%90%9E%E7%AC%91%E7%9A%84%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[最近这段时间一直在抢茅台，是想着以后去TXH家上门提亲的时候能用上，再加两条中华，感觉挺隆重的了。而且为了能有资格购买，还充了京东plus，天猫会员，88会员，花了不少钱和时间，结果酒还没抢到，我人已经要受不了她了。 之前我写的移民计划里面也有TXH的部分，一直都想问她有没有移民的想法来着。因为我觉得我们三观还挺合，说不定她也想离开这个大粪坑。如果有这个想法的话，我们可以一起努力，我主申而她作为配偶副申，可是每次跟他打电话都像欠了她钱似的，我就懒得问了。可以说在我原本的人生规划里面是有她的，只要她能稍微正常一点，可是她做不到。 今天跟她把话挑明了，我的耐心是有限的。估计她还挺得意，说“我早料到了”，想着考验我一段时间，看我能坚持多久。然后我撂挑子了，估计会想“我就知道你坚持不了多久的”，“果然闺蜜说的没错”balabala的。 对此我只能说加油，继续相信你的闺蜜，继续作吧，还能作几年，马上奔三的人了。 就这样吧，得抽空把原本的规划改改咯。]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-114 Flatten Binary Tree to Linked List]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-114%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 12345 1 / \ 2 5 / \ \3 4 6 The flattened tree should look like: 12345678910111 \ 2 \ 3 \ 4 \ 5 \ 6 思路: ​ 一开始还以为是把树转成LinkedList，想着还挺简单，弄个先序遍历add进去就完事了。后来才发现理解错题意了。 代码: 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private TreeNode prev = null; public void flatten(TreeNode root) &#123; if (root == null)&#123; return; &#125; flatten(root.right); flatten(root.left); root.right = prev; root.left = null; prev = root; &#125;&#125; 看见这种特别短的代码就头疼，没搞清楚递归的执行顺序，导致看不懂。今天先不做了，消化一下，没弄懂的地方还很多。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-113 Path Sum II]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-113%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 1234567 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1 Return: 1234[ [5,4,11,2], [5,8,4,5]] 思路: ​ 和上一题类似，DFS先序遍历，建一个二维数组，遍历的时候add进去，但是具体代码写不出来，还是会卡住。 代码: 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; current = new ArrayList&lt;Integer&gt;(); return helper(root,sum,result,current); &#125; public List&lt;List&lt;Integer&gt;&gt; helper(TreeNode root,int sum,List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; current)&#123; if (root == null)&#123; return result; &#125; current.add(root.val); if (root.left == null &amp;&amp; root.right == null &amp;&amp; sum == root.val)&#123; result.add(new ArrayList(current)); &#125; helper(root.left,sum -root.val,result,current); helper(root.right,sum -root.val,result,current); current.remove(current.size()-1); return result; &#125;&#125; 递归这块还是有些薄弱，其实还是没能彻底弄懂递归的原理，不过比起几天前有进步了，之前连思路都没有。现在好歹有思路了，只是写不出来。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-112 Path Sum]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-112%2F</url>
    <content type="text"><![CDATA[Level: Easy Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 1234567 5 / \ 4 8 / / \ 11 13 4 / \ \7 2 1 return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 123456789101112131415161718/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if(root == null) return false; if(root.left == null &amp;&amp; root.right == null) return sum == root.val; return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); &#125;&#125; 为啥有时候Easy的题目也做不出来。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-111 Minimum Depth of Binary Tree]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-111%2F</url>
    <content type="text"><![CDATA[Level: Easy Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its minimum depth = 2. 自己的解 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int minDepth(TreeNode root) &#123; int depth = 1; if (root == null)&#123; return 0; &#125; return helper(root,depth); &#125; public int helper(TreeNode root,int depth)&#123; depth ++; if (root.left != null)&#123; helper(root.left,depth); &#125; if(root.right != null)&#123; helper(root.right,depth); &#125; return depth; &#125;&#125; 然而是错的。 正确答案: 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int minDepth(TreeNode root) &#123; if (root == null)&#123; return 0; &#125; return helper(root); &#125; public int helper(TreeNode root)&#123; if (root.left == null) &#123; return minDepth(root.right) + 1; &#125; if (root.right == null) &#123; return minDepth(root.left) + 1; &#125; return Math.min(minDepth(root.left),minDepth(root.right)) + 1; &#125;&#125; 大体框架上是对了，但是细节还是不对，还是很菜。。。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-110 Balanced Binary Tree]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-110%2F</url>
    <content type="text"><![CDATA[Level: Easy Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Example 1: Given the following tree [3,9,20,null,null,15,7]: 12345 3 / \9 20 / \ 15 7 Return true. Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]: 1234567 1 / \ 2 2 / \ 3 3 / \4 4 思路: ​ 个人想法，DFS然后用一个变量记录高度，看了评论区发现并没有这样的实现。 为什么难度为Easy的题目我却看不懂。 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isBalanced(TreeNode root) &#123; if(root == null)&#123; return true; &#125; return helper(root) != -1; &#125; private int helper(TreeNode root)&#123; if(root == null)&#123; return 0; &#125; int left = helper(root.left); int right = helper(root.right); if(left == -1 || right == -1 || Math.abs(left - right) &gt; 1)&#123; return -1; &#125; return Math.max(left, right) + 1; &#125;&#125; 可能是对高度不熟吧，第一次碰见高度的题。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-108 Convert Sorted Array to Binary Search Tree]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-108%2F</url>
    <content type="text"><![CDATA[Level: Easy Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted array: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 思路: ​ 先找出根节点，再分别构建左右子树。由于是排序好的Array，那么数组中间的数就是这棵树的根节点。int middle = start + (end-start)/2;和int middle = (start+end)/2;后一种写法可能会造成integer overflow，为了避免这个应该尽量使用第一种。 解: 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; if (nums.length == 0 || nums == null)&#123; return null; &#125; return helper(nums,0,nums.length -1); &#125; public TreeNode helper(int[] nums, int start, int end)&#123; if (start &gt; end)&#123; return null; &#125; int middle = start + (end-start)/2; TreeNode node = new TreeNode(nums[middle]); node.left = helper(nums, start, middle -1); node.right = helper(nums, middle+1, end); return node; &#125;&#125; 写树的算法，渐渐的有些感觉了。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-107 Binary Tree Level Order Traversal II]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-107%2F</url>
    <content type="text"><![CDATA[Level: Easy Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its bottom-up level order traversal as: 12345[ [15,7], [9,20], [3]] 类似于之前的102题，奇怪的是，102难度为Medium，而这题难度为Easy。 不过有点记不清之前的思路了，只记得用了Queue，利用Queen FIFO的特性。而这题可以用Stack，LIFO。 不过Stack没怎么玩过，看了眼评论区，发现还是用的Queue，最后add的时候用的是list.add(0,item);看到这终于弄懂了之前Z形层次遍历产生的一个疑问，也就是当时list.add(0,xx);的作用。之前一直以为如果add的地方原本有值，会把原来的值给覆盖掉，所以之前看到的时候没有搞懂这种写法。 有用的知识增加了.jpg 解: 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (root == null) &#123; return result; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; List&lt;Integer&gt; level = new ArrayList&lt;Integer&gt;(); int level_lengh = queue.size(); for (int i = 0; i &lt; level_lengh; i++) &#123; TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) &#123; queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; &#125; result.add(0, level); &#125; return result; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-106 Construct Binary Tree from Inorder and Postorder Traversal]]></title>
    <url>%2F2020%2F04%2F08%2FLeetCode-106%2F</url>
    <content type="text"><![CDATA[Level: Medium Given inorder and postorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given 12inorder = [9,3,15,20,7]postorder = [9,15,7,20,3] Return the following binary tree: 12345 3 / \9 20 / \ 15 7 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] inorder, int[] postorder) &#123; if (inorder == null || postorder == null || inorder.length != postorder.length) &#123; return null; &#125; Map&lt;Integer, Integer&gt; inMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; inorder.length; i++) &#123; inMap.put(inorder[i], i); &#125; return buildTreeHelper(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1, inMap); &#125; public TreeNode buildTreeHelper(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd, Map&lt;Integer, Integer&gt; inMap) &#123; if (inStart &gt; inEnd || postStart &gt; postEnd) &#123; return null; &#125; TreeNode root = new TreeNode(postorder[postEnd]); int numerLeft = inMap.get(postorder[postEnd]); root.left = buildTreeHelper(inorder, inStart, numerLeft - 1, postorder, postStart, postStart + numerLeft - inStart - 1, inMap); root.right = buildTreeHelper(inorder, numerLeft + 1, inEnd, postorder, postStart + numerLeft - inStart, postEnd - 1, inMap); return root; &#125; &#125; 对于左右子树索引的计算和传入还有些困惑，例如 1postStart + numerLeft - inStart - 1 和 1postStart + numerLeft - inStart 下次再做一遍，加深理解。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 105 Construct Binary Tree from Preorder and Inorder Traversal]]></title>
    <url>%2F2020%2F04%2F03%2FLeetCode-105%2F</url>
    <content type="text"><![CDATA[Level: Medium Construct Binary Tree from Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given 12preorder = [3,9,20,15,7]inorder = [9,3,15,20,7] Return the following binary tree: 12345 3 / \9 20 / \ 15 7 思路： ​ 没有 阅读理解 方法1 12345678910111213141516171819public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return helper(0, 0, inorder.length - 1, preorder, inorder);&#125;public TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) &#123; if (preStart &gt; preorder.length - 1 || inStart &gt; inEnd) &#123; return null; &#125; TreeNode root = new TreeNode(preorder[preStart]); int inIndex = 0; // Index of current root in inorder for (int i = inStart; i &lt;= inEnd; i++) &#123; if (inorder[i] == root.val) &#123; inIndex = i; &#125; &#125; root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder); root.right = helper(preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder); return root;&#125; 方法2 1234567891011121314151617181920212223public TreeNode buildTree(int[] preorder, int[] inorder) &#123; Map&lt;Integer, Integer&gt; inMap = new HashMap&lt;Integer, Integer&gt;(); for(int i = 0; i &lt; inorder.length; i++) &#123; inMap.put(inorder[i], i); &#125; TreeNode root = buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, inMap); return root;&#125;public TreeNode buildTree(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd, Map&lt;Integer, Integer&gt; inMap) &#123; if(preStart &gt; preEnd || inStart &gt; inEnd) return null; TreeNode root = new TreeNode(preorder[preStart]); int inRoot = inMap.get(root.val); int numsLeft = inRoot - inStart; root.left = buildTree(preorder, preStart + 1, preStart + numsLeft, inorder, inStart, inRoot - 1, inMap); root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd, inorder, inRoot + 1, inEnd, inMap); return root;&#125; 方法3 12345678910111213141516171819 public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if(preorder.length!=inorder.length) return null; return build(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1);&#125;public TreeNode build(int [] preorder, int preLow, int preHigh, int[] inorder, int inLow, int inHigh)&#123; if(preLow&gt;preHigh || inLow&gt;inHigh) return null; TreeNode root = new TreeNode(preorder[preLow]); int inorderRoot = inLow; for(int i=inLow;i&lt;=inHigh;i++)&#123; if(inorder[i]==root.val)&#123; inorderRoot=i; break; &#125; &#125; int leftTreeLen = inorderRoot-inLow; root.left = build(preorder, preLow+1, preLow+leftTreeLen, inorder, inLow, inorderRoot-1); root.right = build(preorder, preLow+leftTreeLen+1, preHigh, inorder, inorderRoot+1, preHigh); return root; &#125; 这几个方法思路是一样的，区别在于获取中序遍历root位于数组中的index的方法不同，一个用了遍历，一个用了HashMap，当然几个都有一个共同的前提，数组里没有重复的数。 看了很久的代码，大致上明白了，总的思路如下: 前序遍历的第一位一定是树的根节点，根据这个特性我们可以知道这棵树的根节点，进一步可以知道中序数组中根节点的位置。 中序遍历的特点是根节点左边为左子树，右边为右子树。 结合这两点可以知道这棵树左右节点的数量。 找到各个子树的根节点 root 构建该根节点的左子树 构建该根节点的右子树 自以为看懂了，去做106，结果做到关键地方还是卡住了，不知道是应该加还是减，说明还是没完全搞懂，先消化一下，明天再做106吧。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-104 Maximum Depth of Binary Tree]]></title>
    <url>%2F2020%2F04%2F02%2FLeetCode-104%2F</url>
    <content type="text"><![CDATA[Maximum Depth of Binary Tree Level: Easy Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its depth = 3. 思路: ​ 这题比较简单，用递归实现，中途想像平常的DFS一样直接return，想了想发现不行，然后卡了会。得把左右都算出来，比较一下，深度再加1。 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if (root == null)&#123; return 0; &#125; int left = 0; int right = 0; if (root.left != null)&#123; left = maxDepth(root.left); &#125; if (root.right != null)&#123; right = maxDepth(root.right); &#125; return left&gt;=right?left+1:right+1; &#125;&#125; 总体写下来还比较顺，没用idea，页面里纯手写，一次编译运行通过。虽然是个Easy难度的题目，但还是能感受到因为进步带来的小小的成就感。 提交完，照旧看了下讨论区。发现别人只要一行就实现了，淦。 1234567public class Solution &#123; public int maxDepth(TreeNode root) &#123; return root==null? 0 : Math.max(maxDepth(root.left), maxDepth(root.right))+1; &#125;&#125;//https://leetcode.com/problems/maximum-depth-of-binary-tree/discuss/34216/Simple-solution-using-Java// author:dennyrong 看了下，大致 的思路是一样的。三元运算符我也用到了，只不过真没想过用Math.max()这个函数，还是得继续努力呀。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-103 Binary Tree Zigzag Level Order Traversal]]></title>
    <url>%2F2020%2F04%2F02%2FLeetCode-103%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] 思路: ​ 题目的需求跟102题很相似，第一反应就是先照着102写，然后在这个基础之上改改。主要是想着改下面这一段，左改右，右改左之类的。 123456if (node.left != null) &#123; queue.add(node.left);&#125;if (node.right != null) &#123; queue.add(node.right);&#125; 而然改了半天，发现做不到题目要求的效果。于是乎又求助评论区。果然在原有的基础上加了个标志位，并且新增了一段 123456if (zigzag) &#123; level.add(0, node.val);&#125;else &#123; level.add(node.val);&#125; 这个代码后，就能符合题目的要求了，和我心里的预期是相符的。 但是没看懂这一段的意义，就去了leetcode cn，希望能找个中文的思路看下。结果让我没想到的是，力扣中国这题的写法居然完全换了一种思路。属实8行。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-102 Binary Tree Level Order Traversal]]></title>
    <url>%2F2020%2F04%2F02%2FLeetCode-102%2F</url>
    <content type="text"><![CDATA[Level: Medium Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] 思路: ​ 层次遍历。 ​ 然而不会写层次遍历，于是直奔评论区，找了个最高赞的答案看了看，大致上看懂了。 算法上面的递归方法也可以写成迭代的形式。我们将树上顶点按照层次依次放入队列结构中，队列中元素满足 FIFO（先进先出）的原则。在 Java 中可以使用 Queue 接口中的 LinkedList实现。在 Python 中如果使用 Queue 结构，但因为它是为多线程之间安全交换而设计的，所以使用了锁，会导致性能不佳。因此在 Python 中可以使用 deque 的 append() 和 popleft() 函数来快速实现队列的功能。第 0 层只包含根节点 root ，算法实现如下：初始化队列只包含一个节点 root 和层次编号 0 ： level = 0。当队列非空的时候：在输出结果 levels 中插入一个空列表，开始当前层的算法。计算当前层有多少个元素：等于队列的长度。将这些元素从队列中弹出，并加入 levels 当前层的空列表中。将他们的孩子节点作为下一层压入队列中。进入下一层 level++。 实现 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (root == null) return levels; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); int level = 0; while ( !queue.isEmpty() ) &#123; // start the current level levels.add(new ArrayList&lt;Integer&gt;()); // number of elements in the current level int level_length = queue.size(); for(int i = 0; i &lt; level_length; ++i) &#123; TreeNode node = queue.remove(); // fulfill the current level levels.get(level).add(node.val); // add child nodes of the current level // in the queue for the next level if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); &#125; // go to next level level++; &#125; return levels; &#125;&#125;/*** https://leetcode-cn.com/problems/binary-tree-level-order-* traversal/solution/er-cha-shu-de-ceng-ci-bian-li-by-leetcode/*/ 方法2: 123456789101112131415161718192021222324List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; List&lt;Integer&gt; level = new ArrayList&lt;&gt;(); int cnt = queue.size(); for (int i = 0; i &lt; cnt; i++) &#123; TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) &#123; queue.add(node.left); &#125; if (node.right != null) &#123; queue.add(node.right); &#125; &#125; res.add(level); &#125; return res;/*** https://leetcode.com/problems/binary-tree-level-order-* traversal/discuss/33450/Java-solution-with-a-queue-used*/]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-101 Symmetric Tree Easy]]></title>
    <url>%2F2020%2F04%2F01%2FLeetCode-101%2F</url>
    <content type="text"><![CDATA[Symmetric Tree Level:Easy 题目: Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 12345 1 / \ 2 2 / \ / \3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 12345 1 / \2 2 \ \ 3 3 Note:Bonus points if you could solve it both recursively and iteratively. 思路，迭代判断第一层是否为空，第二层左右节点是否相等，第三层左子树的左节点是否等于右子树的右节点，并且左子树的右节点是否等于右子树的左节点。 完整代码: 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if (root == null) &#123; return true; &#125; return helper(root.left, root.right); &#125; public boolean helper(TreeNode left, TreeNode right) &#123; if (left == null || right == null) &#123; return left == right; &#125; if (left.val != right.val) &#123; return false; &#125; return helper(left.left, right.right) &amp;&amp; helper(left.right, right.left); &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-100 Same Tree]]></title>
    <url>%2F2020%2F04%2F01%2FLeetCode-100%2F</url>
    <content type="text"><![CDATA[Same Tree Level:Easy 题目: Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: 1234567Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]Output: true Example 2: 1234567Input: 1 1 / \ 2 2 [1,2], [1,null,2]Output: false Example 3: 1234567Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2]Output: false 解答: 脑海里的第一个想法就是遍历两棵树，然后比较相同节点的大小，但凡有一个不相等就说明不是同样的树。具体思路: 首先判断两个节点是否为空 123456if(p==null&amp;&amp;q==null)&#123; return true;&#125;if(p!=null||q!=null)&#123; return false;&#125; 然后对比根节点root，根节点不同直接返回false，根节点相同再判断左右子节点。 12345if(p.val==q.val)&#123; return isSameTree(p.left==q.left)&amp;&amp;isSameTree(p.right==q.right);&#125;else&#123; return false;&#125; 完整代码 123456789101112131415161718192021/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if (p == null || q == null) &#123; return (p==q); &#125; if (p.val == q.val) &#123; return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); &#125; else &#123; return false; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移民计划]]></title>
    <url>%2F2020%2F04%2F01%2F%E7%A7%BB%E6%B0%91%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[移民 加拿大 移民快速通道 Express Entry基本要求 打算居住在魁北克以外的省份； 过去10年内，有带薪的、一年以上的连续的全职（或等同的兼职）工作，从事同一个职业，在NOC 0，A或者B类别中； 英语或法语至少达到CLB 7级（雅思4个6）； 六项打分超过67。 年龄: 27(30岁一下最高分) 12分学历: 本科 21分(博士25(满分),硕士23(看能不能弄个硕士学位))雅思: 6/6/6/6 16分工作: 5 年 13分(满分15 6年)单身: 0总: 62分数不够入池,除非找个女朋友或者雅思7 联邦技术移民 Federal Skilled Workers总分336差的太多 安省优才计划 – 快速通道NSNP新斯科舍省提名移民项目 - NSNP紧缺职业EE类别 - Catogory B不需要雇主offer SINP萨省提名移民项目 - 2019- 萨省无雇主技术移民项目 SINP 技术移民EE类别（International Skilled Worker: Saskatchewan Express Entry） SINP 技术移民OID类别（International Skilled Worker: Occupation In-Demand） SINP EE类别申请条件 - 飞出国SINP技术移民EE类别要求申请人的职业在萨省紧缺职业列表当中，首先需满足联邦技术移民67分评分标准进入EE池，这也就意味着该类申请人雅思需要达到4个6的成绩，同时还需满足SINP评分60分的标准。 成功创建EE，并进入EE候选池，获得EE账户号码（Express Entry profile Number）和求职验证代码（Job Seeker Validation Code）； 获得SINP萨省技术移民评分标准100分中的60分； 提供指定考试机构出具的有效语言考试成绩，考试成绩应与EE账户中所提交的成绩相匹配； 完成与加拿大教育体系相匹配的至少一年的高等教育、培训或学徒期，并获得文凭、证书或学位； 海外学历申请人需通过指定机构的ECA学历认证； 申请人的专业或受训职业必须符合以下所列条件之一： 过去10年中至少1年非技工类有偿工作经验； 过去5年中至少2年技工类有偿工作经验；或 过去3年中至少12个月加拿大工作经验（技工类或非技工类均可）； 职业必须在萨省紧缺职业列表当中，并且属于NOC 0、A、B类； 如果申请人的职业在萨省为受管制职业，则需首先通过萨省认证，才能提交移民申请； 具备充足的安家资金及定居计划。 SINP OID类别申请条件 - 飞出国SINP技术移民OID类别要求申请人的职业在萨省紧缺职业列表当中，满足SINP评分60分的标准，其中语言打分与EE类别略有不同，OID类别语言达到CLB 4即可得到12分加分，这一标准不适用于EE类别，因此许多雅思无法达到4个6的申请人，只要其他条件满足即可通过该途径申请移民。 获得SINP萨省技术移民评分标准100分中的60分； 语言至少达到CLB4，雇主和监管机构可能会要求更高的语言成绩； 完成与加拿大教育体系相匹配的至少一年的高等教育、培训或学徒期，并获得文凭、证书或学位； 海外学历申请人需通过指定机构的ECA学历认证； 过去十年内具备至少一年相关工作经验，职业类别属于NOC 0、A和B类； 如果申请人的职业在萨省为受管制职业，则需首先通过萨省认证，才能提交移民申请； 具备充足的安家资金及定居计划。 杂QSW 魁省，20180802后实施高分选，法语将变的最重要，其次是魁北克学历且高分专业，再次是有job offer的，三者有2项以上的基本无悬念。需要法语好或专业好，最新受训加分调整，计算机,会计，航空航天，银行和金融，生物，土木建筑，地球，电子电气，食品，地质，水文，机械，护理，物理，植物，食品加工等只有9分。 SINP 萨省，20180716后改为 EOI 择优选，第一次邀请68分，有萨省亲属，有萨省留学和工作经验的申请人更占优势。分为EE和OID（非EE）两种类型，雅思要求低，适合工作经验久的申请人，热门紧缺职业：工程师经理，土木、计算机软硬件工程师，农业，园林，电子维修，经济学家可以申请； NSNP 新省，当前还是抢配额，2018年只开放一次，当前只有EE，核心紧缺职业：金融审计会计，广告，市场，公关，行政助理，财务出纳，土木工程，护士，大专院校讲师，社工，抢配额工作量大，而且职业清单和申请流程说变就变；另外20180802 NS LMP 增加了直接去EE池子里挑选紧缺职业的类别。 OINP 安省 ，分为高分类别（HCP类EE分数400分以上有希望，偶尔有职业限制，当前邀请分数在430分以上，2018年4月后没有再邀请）和法语类别（法语B2，申请人少，无EE分数和配额限制）；安省认可大学的硕博可以无雇主offer移民，限定学校，学历，且需要毕业2年内申请 NBNP NB省，有直系亲属，法语好或参加过宣讲会且职业属于计算机，厨师，酒店餐饮服务经理，会计出纳，健康护理经理，零售主管等，需要满足加拿大联邦EE要求。 MPNP 曼省，有曼省紧缺职业工作经验且与曼省有紧密联系，包括曼省有亲戚朋友担保，有曼省留学、工作经验，有曼省自己的EOI评分，，分为 EE 和 HCP（非EE） PEIPNP PEI EE 类别允许无雇主offer，但要求与 PEI 有较紧密联系，例如PEI工作过，留学过，有亲属，有房产等，需要满足加拿大联邦EE要求 澳大利亚 技术移民 491]]></content>
      <tags>
        <tag>计划</tag>
        <tag>移民</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雅思备考计划]]></title>
    <url>%2F2020%2F03%2F25%2F%E9%9B%85%E6%80%9D%E5%A4%87%E8%80%83%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[计划 准备 iPad Pro 蹲一个教育优惠 剑桥雅思真题9-14? 4-9?4-14? 正版太贵，尽量支持正版吧，不行就盗版。 安静的地方，在附近物色一个图书馆，周末泡图书馆，6月房子到期，到时候还的重新找个。 图书馆的准备 水杯 iPad 手机 耳机 书 笔记本 笔 充电宝？ 包 一个一起学习的女朋友 干净的着装 时间安排合理利用工作的空余时间，上下班的通勤时间，以及周末和假期。上下班通勤时间2个小时左右。刨去走路和骑车所花的时间，单在地铁车厢里的时间保守估计有1小时30分左右。 周末: 9点，起床，半个小时洗漱，吃早餐 9点30 出门 到图书馆时间未定 12点吃饭 午休一小时 1点继续 5点吃晚饭 离开时间待定 更细致的安排待定，比如背单词多少分钟，写作多少分钟，听力多少分钟。待早期的摸索和后期的调整。 考虑是否应该设置休息日，还是说每日余下的时间作为休息就足够了。 目的听/读/写/说 8/7/7/7找一个志同道合的女朋友]]></content>
  </entry>
  <entry>
    <title><![CDATA[移民相关]]></title>
    <url>%2F2020%2F03%2F24%2F%E7%A7%BB%E6%B0%91%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[大学时的计划30岁之前移民的，不知不觉只剩5年了，再这样浑浑噩噩，感觉就实现不了了。 要开始做一些详细的准备了，暂定这几个国家(特地不加地区) 台湾：融入很方便 日本：职场压力比较大的样子 美国：最向往，技术移民太难，移民政策收紧，只能想着过去生个孩子，帮下一代弄个美国籍。 加拿大：天气有点冷，有百万移民的政策。 新西兰：听说四国里最简单的，优势是回头签。年龄和职业是优势，最大的问题是英语，雅思得7炸或者8炸。计划WHV签证落地，找工作换长期签证。可惜19年停止了银蕨签证，又少了个渠道。 澳大利亚：好像对华人不太友好。政策收紧，EOI分数要求越来越高。 希望能有个一起努力的女朋友，不知道txh愿不愿意移民。配偶英语不错也能加分。]]></content>
  </entry>
  <entry>
    <title><![CDATA[快乐周末]]></title>
    <url>%2F2019%2F12%2F21%2F%E5%BF%AB%E4%B9%90%E5%91%A8%E6%9C%AB%2F</url>
    <content type="text"><![CDATA[斯达拉斯达拉新西游记第七季 闲着干嘛呢 RM 炎炎消防队]]></content>
  </entry>
  <entry>
    <title><![CDATA[爱在黎明破晓前]]></title>
    <url>%2F2019%2F08%2F11%2F%E7%88%B1%E5%9C%A8%E9%BB%8E%E6%98%8E%E7%A0%B4%E6%99%93%E5%89%8D%2F</url>
    <content type="text"><![CDATA[以前对爱情期待的时候看了好多的爱情片，印象比较深刻的就是这部《爱在黎明破晓前》。 其实是个三部曲还有《爱在午夜黄昏后》《爱在午夜降临前》。 讲个两个陌生人相遇，相爱，分开，再相遇的故事。 两个互不相识的人相爱，真的很美好。]]></content>
  </entry>
  <entry>
    <title><![CDATA[用心良苦]]></title>
    <url>%2F2019%2F08%2F10%2F%E7%94%A8%E5%BF%83%E8%89%AF%E8%8B%A6%2F</url>
    <content type="text"><![CDATA[你说你 想要逃]]></content>
  </entry>
  <entry>
    <title><![CDATA[起风了]]></title>
    <url>%2F2019%2F08%2F09%2F%E8%B5%B7%E9%A3%8E%E4%BA%86%2F</url>
    <content type="text"><![CDATA[台风要来了，第一次经历台风呢。]]></content>
  </entry>
  <entry>
    <title><![CDATA[形势不对]]></title>
    <url>%2F2019%2F08%2F06%2F%E5%BD%A2%E5%8A%BF%E4%B8%8D%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[可惜没存款，不然换点美金。 现今之际，只能存点粮食，水，日常药品。]]></content>
  </entry>
  <entry>
    <title><![CDATA[健身记录]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%81%A5%E8%BA%AB%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[买的健身装备到了，今天开始健身，记录下身材的变化。 2019-08-06 健身0天： 一个月后再记录一次。 2019-08-11 健身第一天]]></content>
  </entry>
  <entry>
    <title><![CDATA[吉他练习]]></title>
    <url>%2F2019%2F08%2F04%2F%E5%90%89%E4%BB%96%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[2019-08-04 认识六线谱，了解弦和品，练习《小星星》。 2019-08-04 忙别的去了，练习《小星星》30分钟。每天最少1小时，明天补起来。]]></content>
  </entry>
  <entry>
    <title><![CDATA[好想哭一场]]></title>
    <url>%2F2019%2F07%2F30%2F%E5%A5%BD%E6%83%B3%E5%93%AD%E4%B8%80%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[500篇特辑 （无挑看多了划掉]]></title>
    <url>%2F2019%2F07%2F03%2F500%E7%AF%87%E7%89%B9%E8%BE%91%20%EF%BC%88%E6%97%A0%E6%8C%91%E7%9C%8B%E5%A4%9A%E4%BA%86%E5%88%92%E6%8E%89%2F</url>
    <content type="text"><![CDATA[并没有什么要说的，抽空把以前太监的博客给更新掉比如&lt;四个&gt;，其实还挺想写的就是懒。 好好还钱，早点还清，早点回家。 好好锻炼，争取练到能一👊打死七七。 完。]]></content>
  </entry>
  <entry>
    <title><![CDATA[香港加油！]]></title>
    <url>%2F2019%2F06%2F16%2F%E9%A6%99%E6%B8%AF%E5%8A%A0%E6%B2%B9%EF%BC%81%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于求婚]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%85%B3%E4%BA%8E%E6%B1%82%E5%A9%9A%2F</url>
    <content type="text"><![CDATA[关于求婚，我之前想了很多，假象的对象是七七。 但我觉得按照现在的情况继续发展下去，我应该会和TXH结婚吧，三观挺合适的，相处起来很舒服。 之所以今天会突然有这股冲动，是因为在YouTube无意间看到一个手工做钻戒的视频，真的很cool。 Before After 既然我能为女朋友做网站，那我也能为自己未来老婆做更多，哪个女生这么幸运呢。]]></content>
  </entry>
  <entry>
    <title><![CDATA[是真爱了]]></title>
    <url>%2F2019%2F05%2F13%2F%E6%98%AF%E7%9C%9F%E7%88%B1%E4%BA%86%2F</url>
    <content type="text"><![CDATA[txh是真的喜欢我，就像我当时那么哔哔哔哔哔 (我不想被车撞死 “所以沟通很重要”，只有懂的人才懂，真的喜欢对方才会这样和对方说，是希望能和对方感情好好的，不会因为误会吵架。 曾几何时，我也哔哔哔哔。]]></content>
  </entry>
  <entry>
    <title><![CDATA[感冒了]]></title>
    <url>%2F2019%2F05%2F04%2F%E6%84%9F%E5%86%92%E4%BA%86%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Japan]]></title>
    <url>%2F2019%2F04%2F04%2FJapan%2F</url>
    <content type="text"><![CDATA[哟嚯，约了朋友去日本玩。 顺便完成一起去日本的约定。 得先去办护照，和签证。 期待！ 未完待续。 update 2019-04-07 可惜，没有单反。一直想要个单反没舍得买，今年是没机会了/]]></content>
  </entry>
  <entry>
    <title><![CDATA[想早点离开]]></title>
    <url>%2F2019%2F02%2F24%2F%E6%83%B3%E6%97%A9%E7%82%B9%E7%A6%BB%E5%BC%80%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[有个特别想写的]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%9C%89%E4%B8%AA%E7%89%B9%E5%88%AB%E6%83%B3%E5%86%99%E7%9A%84%2F</url>
    <content type="text"><![CDATA[留到重要的日子吧，比如生日再写。 今天很开心，偶然的想起一段尘封的往事。得好好构思一下，再润润色，争取写的优美一些。]]></content>
  </entry>
  <entry>
    <title><![CDATA[好累不想写]]></title>
    <url>%2F2019%2F02%2F15%2F%E5%A5%BD%E7%B4%AF%E4%B8%8D%E6%83%B3%E5%86%99%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[爱情]]></title>
    <url>%2F2019%2F02%2F10%2F%E7%88%B1%E6%83%85%2F</url>
    <content type="text"><![CDATA[若不是因为爱着你 怎么会夜深还没睡意 每个念头都关於你 我想你 想你 好想你 ──莫文蔚 爱情]]></content>
      <categories>
        <category>我独自生活</category>
      </categories>
      <tags>
        <tag>我独自生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[弱智]]></title>
    <url>%2F2019%2F02%2F05%2F%E5%BC%B1%E6%99%BA%2F</url>
    <content type="text"><![CDATA[我是个弱智]]></content>
  </entry>
  <entry>
    <title><![CDATA[喝醉了]]></title>
    <url>%2F2019%2F02%2F02%2F%E5%96%9D%E9%86%89%E4%BA%86%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[回家]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%9B%9E%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[回家了，不来了 相亲，结婚]]></content>
      <categories>
        <category>我独自生活</category>
      </categories>
      <tags>
        <tag>我独自生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[想要幸福]]></title>
    <url>%2F2019%2F01%2F14%2F%E6%83%B3%E8%A6%81%E5%B9%B8%E7%A6%8F%2F</url>
    <content type="text"><![CDATA[都这么自律了 标准好男人，怎么就得不到幸福呢。 难道真的要变成坏男人，才会有女生死心塌地的喜欢吗。]]></content>
      <categories>
        <category>我独自生活</category>
      </categories>
      <tags>
        <tag>我独自生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加班到最后一个人]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%8A%A0%E7%8F%AD%E5%88%B0%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[也算是难得的经历了]]></content>
      <categories>
        <category>我独自生活</category>
      </categories>
      <tags>
        <tag>我独自生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[啊，失眠了]]></title>
    <url>%2F2019%2F01%2F06%2F%E5%95%8A%EF%BC%8C%E5%A4%B1%E7%9C%A0%E4%BA%86%2F</url>
    <content type="text"><![CDATA[打哈欠 都不知道昨天几点睡着的，可能4点，可能5点。 心里莫名烦躁呢。]]></content>
      <categories>
        <category>我独自生活</category>
      </categories>
      <tags>
        <tag>我独自生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一月规划]]></title>
    <url>%2F2019%2F01%2F05%2F%E4%B8%80%E6%9C%88%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[想你的第 不重要，咳咳 完成手头的工作(废话) 拾掇自己 买一双喜欢的👟！好久没买鞋了，买双AJ4吧。 衣服👔 裤子👖 剪寸头💇‍♂️ 坚持练字✍️ 多出门走走不要宅了🐶 (难度：🌟🌟🌟🌟🌟)]]></content>
      <categories>
        <category>相遇</category>
      </categories>
      <tags>
        <tag>相遇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[答应不爱你]]></title>
    <url>%2F2018%2F10%2F07%2F%E7%AD%94%E5%BA%94%E4%B8%8D%E7%88%B1%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[虽然很努力练习着忘记我的心却还没答应可以放弃了你 ──答应不爱你 郑中基 明明爱很清晰却又接受分离我只剩思念的权利难过还来不及爱早已融入呼吸不存在的存在心底虽然很努力练习着忘记我的心却还没答应可以放弃了你真的对不起答应了你不再爱你我却还没答应我自己明明爱很清晰却要接受分离我只剩思念的权利难过还来不及就让爱融入空气不存在的存在心底说好要忘记偏偏又想起原来我的心还没有答应放弃了你真的对不起虽然曾经答应了你我却还没答应我自己却又如何真的不爱你──答应不爱你 郑中基]]></content>
      <categories>
        <category>听歌</category>
      </categories>
      <tags>
        <tag>听歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样]]></title>
    <url>%2F2018%2F10%2F06%2F%E6%80%8E%E6%A0%B7%2F</url>
    <content type="text"><![CDATA[如果我们现在还在一起会是怎样我们是不是还是深爱着对方 ──怎样 戴佩妮 我这里天快要黑了那里呢我这里天气凉凉的那里呢我这里一切都变了我变的懂事了我又开始写日记了而那你呢我这里天快要亮了那里呢我这里天气很炎热那里呢我这里一切都变了我变的不哭了我把照片也收起了而那你呢如果我们现在还在一起会是怎样我们是不是还是深爱着对方像开始时那样握着手就算天快亮我们现在还在一起会是怎样我们是不是还是隐瞒着对方像结束时那样明知道你没有错还硬要我原谅我这里天快要亮了那里呢我这里天气很炎热那里呢我这里一切都变了我变的不哭了我把照片也收起了而那你呢如果我们现在还在一起会是怎样我们是不是还是深爱着对方像开始时那样握着手就算天快亮我们现在还在一起会是怎样我们是不是还是隐瞒着对方像结束时那样明知道你没有错还硬要我原谅如果我们现在还在一起会是怎样我们是不是还是深爱着对方像开始时那样握着手就算天快亮我们现在还在一起会是怎样我们是不是还是隐瞒着对方像结束时那样明知道你没有错还硬要我原谅我不会原谅我怎么原谅──怎样 戴佩妮]]></content>
      <categories>
        <category>听歌</category>
      </categories>
      <tags>
        <tag>听歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[退后]]></title>
    <url>%2F2018%2F10%2F02%2F%E9%80%80%E5%90%8E%2F</url>
    <content type="text"><![CDATA[我知道我们都没有错 只是放手会比较好过 ──周杰伦 退后 天空灰的像哭过离开你以后并没有 更自由酸酸的空气嗅出我们的距离一幕锥心的结局像呼吸般无法停息抽屉泛黄的日记榨干了回忆那笑容 是夏季你我的过去被顺时针的忘记缺氧过后的爱情粗心的眼泪是多余我知道你我都没有错只是忘了怎么退后信誓旦旦给了承诺却被时间扑了空我知道我们都没有错只是放手会比较好过最美的爱情回忆里待续天空灰的像哭过离开你以后并没有 更自由酸酸的空气嗅出我们的距离一幕锥心的结局像呼吸般无法停息抽屉泛黄的日记榨干了回忆那笑容 是夏季你我的过去被顺时针的忘记缺氧过后的爱情粗心的眼泪是多余我知道你我都没有错只是忘了怎么退后信誓旦旦给了承诺却被时间扑了空我知道我们都没有错只是放手会比较好过最美的爱情回忆里待续我知道你我都没有错只是忘了怎么退后信誓旦旦给了承诺却被时间扑了空我知道我们都没有错只是放手会比较好过最美的爱情回忆里待续──周杰伦 退后]]></content>
      <categories>
        <category>听歌</category>
      </categories>
      <tags>
        <tag>听歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记事本]]></title>
    <url>%2F2018%2F10%2F01%2F%E8%AE%B0%E4%BA%8B%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[我看见自己写下的心情 把自己放在卑微的后头 ──周传雄 记事本 翻开随身携带的记事本写着许多事都是关于你你讨厌被冷落习惯被守候寂寞才找我我看见自己写下的心情把自己放在卑微的后头等你等太久想你泪会流而幸福快乐是什么爱的痛了痛的哭了哭的累了日记本里页页执着记载着你的好像上瘾的毒药它反覆骗着我爱的痛了痛的哭了哭的累了矛盾心里总是强求劝自己要放手闭上眼让你走烧掉日记重新来过我看见自己写下的心情把自己放在卑微的后头等你等太久想你泪会流而幸福快乐是什么爱的痛了痛的哭了哭的累了日记本里页页执着记载着你的好像上瘾的毒药它反复骗着我爱的痛了痛的哭了哭的累了矛盾心里总是强求劝自己要放手闭上眼让你走烧掉日记重新来过爱的痛了痛的哭了哭的累了矛盾心里总是强求劝自己要放手闭上眼让你走烧掉日记重新来过──周传雄 记事本]]></content>
      <categories>
        <category>听歌</category>
      </categories>
      <tags>
        <tag>听歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开不了口]]></title>
    <url>%2F2018%2F09%2F30%2F%E5%BC%80%E4%B8%8D%E4%BA%86%E5%8F%A3%202%2F</url>
    <content type="text"><![CDATA[才离开没多久就开始 担心今天的你过得好不好 ──周杰伦 开不了口 才离开没多久就开始担心今天的你过得好不好整个画面是你 想你想的睡不着嘴嘟嘟那可爱的模样还有在你身上香香的味道我的快乐是你 想你想的都会笑没有你在我有多难熬（没有你在我有多难熬多烦恼）没有你烦我有多烦恼（没有你烦我有多烦恼多难熬）穿过云层 我试着努力向你奔跑爱才送到 你却已在别人怀抱就是开不了口 让她知道我一定会呵护着你 也逗你笑你对我有多重要我后悔没 让你知道安静的听你撒娇看你睡着 一直到老就是开不了口 让她知道就是那么简单几句 我办不到整颗心悬在半空我只能够 远远看着这些我都做得到但那个人已经不是我没有你在我有多难熬（没有你在我有多难熬多烦恼）没有你烦我有多烦恼（没有你烦我有多烦恼多难熬）穿过云层 我试着努力向你奔跑爱才送到 你却已在别人怀抱就是开不了口 让她知道我一定会呵护着你 也逗你笑你对我有多重要我后悔没 让你知道安静的听你撒娇看你睡着 一直到老就是开不了口 让她知道就是那么简单几句 我办不到整颗心悬在半空我只能够 远远看着这些我都做得到但那个人已经不是我──周杰伦 开不了口]]></content>
      <categories>
        <category>听歌</category>
      </categories>
      <tags>
        <tag>听歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今年规划]]></title>
    <url>%2F2018%2F05%2F16%2F%E4%BB%8A%E5%B9%B4%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[今年规划 年底回武汉 学好英语 养一只狗 照顾好自己 对父母好 珍惜朋友]]></content>
      <categories>
        <category>分手</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
</search>
